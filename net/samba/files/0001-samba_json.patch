diff --git a/source3/include/util_sd.h b/source3/include/util_sd.h
index 7f82969badf..dc4ec88e578 100644
--- a/source3/include/util_sd.h
+++ b/source3/include/util_sd.h
@@ -23,6 +23,12 @@
 
 #ifndef __UTIL_SD_H__
 #define __UTIL_SD_H__
+#ifdef HAVE_JANSSON
+#include <jansson.h>
+#include "audit_logging.h" /* various JSON helpers */
+#include "auth/common_auth.h"
+#endif /*HAVE_JANSSON*/
+
 
 void SidToString(struct cli_state *cli, fstring str, const struct dom_sid *sid,
 		 bool numeric);
@@ -33,5 +39,7 @@ bool parse_ace(struct cli_state *cli, struct security_ace *ace,
 	       const char *orig_str);
 void sec_desc_print(struct cli_state *cli, FILE *f,
 		    struct security_descriptor *sd, bool numeric);
+bool sec_desc_to_json(struct cli_state *cli, struct json_object *out,
+                      struct security_descriptor *sd, bool numeric, bool share_acl);
 
 #endif
diff --git a/source3/lib/util_sd.c b/source3/lib/util_sd.c
index 39083b15438..80eea0b6dac 100644
--- a/source3/lib/util_sd.c
+++ b/source3/lib/util_sd.c
@@ -28,30 +28,47 @@
 #include "../libcli/security/security.h"
 #include "rpc_client/cli_pipe.h"
 #include "rpc_client/cli_lsarpc.h"
+#ifdef HAVE_JANSSON
+#include <jansson.h>
+#include "audit_logging.h" /* various JSON helpers */
+#endif /* [HAVE_JANSSON] */
 
 /* These values discovered by inspection */
 
 struct perm_value {
 	const char *perm;
+	const char *text;
 	uint32_t mask;
 };
 
 static const struct perm_value special_values[] = {
-	{ "R", SEC_RIGHTS_FILE_READ },
-	{ "W", SEC_RIGHTS_FILE_WRITE },
-	{ "X", SEC_RIGHTS_FILE_EXECUTE },
-	{ "D", SEC_STD_DELETE },
-	{ "P", SEC_STD_WRITE_DAC },
-	{ "O", SEC_STD_WRITE_OWNER },
-	{ NULL, 0 },
+	{ "R", "READ", SEC_RIGHTS_FILE_READ },
+	{ "W", "WRITE", SEC_RIGHTS_FILE_WRITE },
+	{ "X", "EXECUTE", SEC_RIGHTS_FILE_EXECUTE },
+	{ "D", "DELETE", SEC_STD_DELETE },
+	{ "P", "WRITE_DAC", SEC_STD_WRITE_DAC },
+	{ "O", "WRITE_OWNER", SEC_STD_WRITE_OWNER },
+	{ NULL, NULL, 0 },
+};
+
+static const struct perm_value extended_values[] = {
+        { "p", "APPEND_DATA", SEC_FILE_APPEND_DATA},
+        { "a", "READ_ATTRIBUTES", SEC_FILE_READ_ATTRIBUTE},
+        { "A", "WRITE_ATTRIBUTES", SEC_FILE_WRITE_ATTRIBUTE},
+        { "r", "READ_EA", SEC_FILE_READ_EA},
+        { "w", "WRITE_EA", SEC_FILE_WRITE_EA},
+        { "d", "DELETE_CHILD", FILE_DELETE_CHILD},
+        { "c", "READ_CONTROL", SEC_STD_READ_CONTROL},
+        { "S", "SYNCHRONIZE", SEC_STD_SYNCHRONIZE},
+	{ NULL, NULL, 0 },
 };
 
 static const struct perm_value standard_values[] = {
-	{ "READ",   SEC_RIGHTS_DIR_READ|SEC_DIR_TRAVERSE },
-	{ "CHANGE", SEC_RIGHTS_DIR_READ|SEC_STD_DELETE|\
+	{ "READ", "READ", SEC_RIGHTS_DIR_READ|SEC_DIR_TRAVERSE },
+	{ "CHANGE", "CHANGE", SEC_RIGHTS_DIR_READ|SEC_STD_DELETE|\
 	  SEC_RIGHTS_DIR_WRITE|SEC_DIR_TRAVERSE },
-	{ "FULL",   SEC_RIGHTS_DIR_ALL },
-	{ NULL, 0 },
+	{ "FULL", "FULL",  SEC_RIGHTS_DIR_ALL },
+	{ NULL, NULL, 0 },
 };
 
 static const struct {
@@ -366,6 +383,369 @@ void print_ace(struct cli_state *cli, FILE *f, struct security_ace *ace,
 	}
 }
 
+static bool add_acl_ctrl_json(struct json_object *jsobj, uint16_t ctrl, bool numeric)
+{
+	struct json_object control, tmp;
+	int i, ret;
+	control = json_new_object();
+	if (json_is_invalid(&control)) {
+		fprintf(stderr, "Failed to get JSON array for ACL control\n");
+		return false;
+	}
+
+	for (i = ARRAY_SIZE(sec_desc_ctrl_bits) - 1; i >= 0; i--) {
+		if (ctrl & sec_desc_ctrl_bits[i].mask) {
+			ret =json_add_bool(&control, sec_desc_ctrl_bits[i].desc, true);
+			if (ret != 0) {
+				fprintf(stderr, "Failed to add control bits\n");
+				json_free(&control);
+				return false;
+			}
+
+		}
+		else {
+			ret = json_add_bool(&control, sec_desc_ctrl_bits[i].desc, false);
+			if (ret != 0) {
+				fprintf(stderr, "Failed to add control bits\n");
+				json_free(&control);
+				return false;
+			}
+		}
+	}
+	ret = json_add_object(jsobj, "control", &control);
+	return true;
+}
+
+static bool add_trustee_json(struct json_object *jsobj, struct cli_state *cli,
+			     const struct dom_sid *sid, char *title,
+			     bool numeric)
+{
+	struct json_object trustee;
+	int ret;
+	NTSTATUS status;
+	char *domain = NULL;
+	char *name = NULL;
+	fstring str;
+
+	enum lsa_SidType type;
+
+	trustee = json_new_object();
+	if (json_is_invalid(&trustee)) {
+		fprintf(stderr, "New JSON object for trustee is invalid\n");
+		return false;
+	}
+	ret = json_add_sid(&trustee, "sid", sid);
+	if (ret != 0) {
+		fprintf(stderr, "Failed to add SID to trustee JSON object: %s\n",
+			strerror(errno));
+		json_free(&trustee);
+		return false;
+	}
+        if (numeric || cli == NULL) {
+		ret = json_add_string(&trustee, "name", "");
+		if (ret != 0) {
+			json_free(&trustee);
+			return false;
+		}
+        }
+	else {
+		status = cli_lsa_lookup_sid(cli, sid, talloc_tos(), &type,
+					    &domain, &name);
+
+		if (!NT_STATUS_IS_OK(status)) {
+			fprintf(stderr, "cli_lsa_lookup_sid failed\n");
+			json_free(&trustee);
+			return false;
+		}
+		if (*domain) {
+			slprintf(str, sizeof(fstring) - 1, "%s%s%s",
+				domain, lp_winbind_separator(), name);
+			ret = json_add_string(&trustee, "name", str);
+			if (ret != 0) {
+				fprintf(stderr, "Failed to add name to trustee: %s",
+					strerror(errno));
+				json_free(&trustee);
+				return false;
+			}
+		} else {
+			ret = json_add_string(&trustee, "name", "");
+			if (ret != 0) {
+				json_free(&trustee);
+				return false;
+			}
+		}
+	}
+	ret = json_add_object(jsobj, title, &trustee);
+	if (ret != 0) {
+		fprintf(stderr, "Failed to %s to JSON object: %s\n",
+			title, strerror(errno));
+		json_free(&trustee);
+		return false;
+	}
+	return true;
+}
+
+static bool add_ace_flags_json(struct json_object *jsobj, uint8_t flags)
+{
+	struct json_object js_flags;
+	int ret;
+	if (json_is_invalid(jsobj)) {
+		return false;
+	}
+	js_flags = json_new_object();
+	if (json_is_invalid(&js_flags)) {
+		return false;
+	}
+
+	ret = json_add_bool(&js_flags, "OBJECT_INHERIT",
+			    (flags & SEC_ACE_FLAG_OBJECT_INHERIT)
+			    ? true : false);
+	if (ret < 0) {
+		goto failure;
+	}
+	ret = json_add_bool(&js_flags, "CONTAINER_INHERIT",
+			    (flags & SEC_ACE_FLAG_CONTAINER_INHERIT)
+			    ? true : false);
+	if (ret < 0) {
+		goto failure;
+	}
+	ret = json_add_bool(&js_flags, "NO_PROPAGATE_INHERIT",
+			    (flags & SEC_ACE_FLAG_NO_PROPAGATE_INHERIT)
+			    ? true : false);
+	if (ret < 0) {
+		goto failure;
+	}
+	ret = json_add_bool(&js_flags, "INHERIT_ONLY",
+			    (flags & SEC_ACE_FLAG_INHERIT_ONLY)
+			    ? true : false);
+	if (ret < 0) {
+		goto failure;
+	}
+	ret = json_add_bool(&js_flags, "INHERITED",
+			    (flags & SEC_ACE_FLAG_INHERITED_ACE)
+			    ? true : false);
+	if (ret < 0) {
+		goto failure;
+	}
+
+	ret = json_add_object(jsobj, "flags", &js_flags);
+	if (ret < 0) {
+		fprintf(stderr, "Failed to add flags to JSON object: %s\n",
+			strerror(errno));
+		return false;
+	}
+	return true;
+
+failure:
+	json_free(&js_flags);
+	return false;
+}
+
+static bool add_perms_json(struct json_object *jsobj,
+			   const struct perm_value *perm,
+			   struct security_ace *ace,
+			   uint32_t *got_mask)
+{
+	int ret;
+	const struct perm_value *v;
+
+	for (v = perm; v->perm; v++) {
+		if ((ace->access_mask & v->mask) == v->mask) {
+			ret = json_add_bool(jsobj, v->text, true);
+			if (ret < 0) {
+				return false;
+			}
+			*got_mask &= ~v->mask;
+		}
+		else {
+			ret = json_add_bool(jsobj, v->text, false);
+			if (ret < 0) {
+				return false;
+			}
+		}
+	}
+	return true;
+}
+
+static bool add_access_mask_json(struct json_object *jsobj,
+				 struct security_ace *ace,
+				 bool share_acl)
+{
+	struct json_object js_amask, special;
+	int ret;
+	const struct perm_value *v;
+	char buf[80];
+	bool has_standard = false;
+	uint32_t got_mask;
+	if (json_is_invalid(jsobj)) {
+		return false;
+	}
+	js_amask = json_new_object();
+	if (json_is_invalid(&js_amask)) {
+		return false;
+	}
+	special = json_new_object();
+	if (json_is_invalid(&special)) {
+		json_free(&js_amask);
+		return false;
+	}
+	snprintf(buf, sizeof(buf), "0x%08x", ace->access_mask);
+	ret = json_add_string(&js_amask, "hex", buf);
+	if (ret < 0) {
+		goto failure;
+	}
+	for (v = standard_values; v->perm; v++) {
+		if (ace->access_mask == v->mask) {
+			ret = json_add_string(&js_amask, "standard", v->perm);
+			if (ret < 0) {
+				json_free(&js_amask);
+				return false;
+			}
+			has_standard = true;
+		}
+	}
+	if (share_acl) {
+		goto done;
+	}
+
+	if (!has_standard) {
+		ret = json_add_string(&js_amask, "standard", "");
+		if (ret < 0) {
+			goto failure;
+		}
+	}
+
+	got_mask = ace->access_mask;
+
+	ret = add_perms_json(&special, special_values, ace, &got_mask);
+	if (!ret) {
+		goto failure;
+	}
+
+	ret = add_perms_json(&special, extended_values, ace, &got_mask);
+	if (!ret) {
+		goto failure;
+	}
+
+	ret = json_add_object(&js_amask, "special", &special);
+	if (ret < 0) {
+		fprintf(stderr,
+			"failed to add special entries to access mask "
+			"JSON object: %s\n", strerror(errno));
+		goto failure;
+	}
+	snprintf(buf, sizeof(buf), "0x%08x", got_mask);
+	ret = json_add_string(&js_amask, "unknown", buf);
+	if (ret < 0) {
+		goto failure;
+	}
+done:
+	ret = json_add_object(jsobj, "access_mask", &js_amask);
+	if (ret < 0) {
+		fprintf(stderr, "Failed to add access mask to JSON object: %s\n",
+			strerror(errno));
+		return false;
+	}
+	return true;
+failure:
+	json_free(&js_amask);
+	json_free(&special);
+	return false;
+}
+
+static bool add_ace_json(struct cli_state *cli, struct json_object *jsobj,
+			 struct security_ace *ace, bool numeric, bool share_acl)
+{
+	const struct perm_value *v;
+	struct json_object jsace, trustee;
+	fstring sidstr;
+	int do_print = 0;
+	int ret;
+	bool rv;
+	char buf[80] = {0};
+	bool has_js_amask = false;
+	if (json_is_invalid(jsobj)) {
+		return false;
+	}
+	jsace = json_new_object();
+	if (json_is_invalid(&jsace)) {
+		fprintf(stderr, "Failed to create new JSON object: %s\n",
+			strerror(errno));
+		return false;
+	}
+	trustee = json_new_object();
+	if (json_is_invalid(&trustee)) {
+		fprintf(stderr, "Failed to create new JSON object: %s\n",
+			strerror(errno));
+		goto failure;
+	}
+
+	rv = add_trustee_json(&jsace, cli, &ace->trustee, "trustee", numeric);
+	if (!rv) {
+		goto failure;
+	}
+
+	if (numeric) {
+		ret = json_add_int(&jsace, "type", ace->type);
+		if (ret < 0 ) {
+			goto failure;
+		}
+		ret = json_add_int(&jsace, "flags", ace->flags);
+		if (ret < 0 ) {
+			goto failure;
+		}
+		snprintf(buf, sizeof(buf), "0x%08x", ace->access_mask);
+		ret = json_add_string(&jsace, "access_mask", buf);
+		if (ret < 0 ) {
+			goto failure;
+		}
+		ret = json_add_object(jsobj, NULL, &jsace);
+		if (ret < 0 ) {
+			goto failure;
+		}
+		return true;
+	}
+	switch(ace->type) {
+	case SEC_ACE_TYPE_ACCESS_ALLOWED:
+		snprintf(buf, sizeof(buf), "%s", "ALLOWED");
+		break;
+	case SEC_ACE_TYPE_ACCESS_DENIED:
+		snprintf(buf, sizeof(buf), "%s", "DENIED");
+		break;
+	default:
+		snprintf(buf, sizeof(buf), "UNKNOWN - %d", ace->type);
+		break;
+	}
+	ret = json_add_string(&jsace, "type", buf);
+	if (ret != 0) {
+		fprintf(stderr,
+			"Failed to add ace_type [%s] to JSON object "
+			"for ACE: %s\n", buf, strerror(errno));
+		goto failure;
+	}
+	ret = add_access_mask_json(&jsace, ace, share_acl);
+	if (!ret) {
+		goto failure;
+	}
+	if (!share_acl) {
+		ret = add_ace_flags_json(&jsace, ace->flags);
+		if (!ret) {
+			goto failure;
+		}
+	}
+	ret = json_add_object(jsobj, NULL, &jsace);
+	if (ret < 0) {
+		fprintf(stderr, "Failed to add new ACE to JSON object: %s\n",
+			strerror(errno));
+		return false;
+	}
+	return true;
+
+failure:
+	json_free(&jsace);
+	return false;
+}
+
 static bool parse_ace_flags(const char *str, unsigned int *pflags)
 {
 	const char *p = str;
@@ -647,3 +1027,71 @@ void sec_desc_print(struct cli_state *cli, FILE *f,
 	}
 
 }
+
+bool sec_desc_to_json(struct cli_state *cli, struct json_object *out,
+		      struct security_descriptor *sd, bool numeric,
+		      bool share_acl)
+{
+	struct json_object jsret, dacl, owner, group, control;
+	fstring sidstr;
+	uint32_t i;
+	int ret;
+	bool rv;
+	jsret = json_new_object();
+	if (json_is_invalid(&jsret)) {
+		fprintf(stderr, "Failed to create new JSON object: %s\n",
+			strerror(errno));
+		return false;
+	}
+	ret = json_add_int(&jsret, "revision", sd->revision);
+	if (ret < 0) {
+		fprintf(stderr, "Failed to add REVISION to JSON object\n");
+		goto failure;
+	}
+
+	if (!share_acl) {
+		rv = add_trustee_json(&jsret, cli, sd->owner_sid, "owner", numeric);
+		if (!rv) {
+			fprintf(stderr, "Failed to add owner to JSON object: %s\n",
+				strerror(errno));
+			goto failure;
+		}
+		rv = add_trustee_json(&jsret, cli, sd->group_sid, "group", numeric);
+		if (!rv) {
+			fprintf(stderr, "Failed to add owner to JSON object: %s\n",
+				strerror(errno));
+			goto failure;
+		}
+	}
+
+	dacl = json_get_array(&jsret, "dacl");
+	if (json_is_invalid(&dacl)) {
+		goto failure;
+	}
+	for (i = 0; sd->dacl && i < sd->dacl->num_aces; i++) {
+		struct security_ace *ace = &sd->dacl->aces[i];
+		ret = add_ace_json(cli, &dacl, ace, numeric, share_acl);
+		if (!ret) {
+			json_free(&dacl);
+			goto failure;
+		}
+	}
+	ret = json_add_object(&jsret, "dacl", &dacl);
+	if (ret == -1) {
+		fprintf(stderr, "Failed to add DACL to jsret: %s\n",
+			strerror(errno));
+	}
+
+	rv = add_acl_ctrl_json(&jsret, sd->type, numeric);
+	if (!rv) {
+		fprintf(stderr, "Failed to do control: %s\n", strerror(errno));
+		goto failure;
+	}
+
+	*out = jsret;
+	return true;
+
+failure:
+	json_free(&jsret);
+	return false;
+}
diff --git a/source3/utils/sharesec.c b/source3/utils/sharesec.c
index 454c5bfe36b..337d8ac82ef 100644
--- a/source3/utils/sharesec.c
+++ b/source3/utils/sharesec.c
@@ -29,6 +29,11 @@ struct cli_state;
 #include "passdb/machine_sid.h"
 #include "util_sd.h"
 #include "cmdline_contexts.h"
+#ifdef HAVE_JANSSON
+#include <jansson.h>
+#include "audit_logging.h" /* various JSON helpers */
+#include "auth/common_auth.h"
+#endif /* [HAVE_JANSSON] */
 
 static TALLOC_CTX *ctx;
 
@@ -157,12 +162,15 @@ static void sort_acl(struct security_acl *the_acl)
 }
 
 
-static int change_share_sec(TALLOC_CTX *mem_ctx, const char *sharename, char *the_acl, enum acl_mode mode)
+static int change_share_sec(TALLOC_CTX *mem_ctx, const char *sharename,
+			    char *the_acl, enum acl_mode mode, struct json_object *jsobj)
 {
 	struct security_descriptor *sd = NULL;
 	struct security_descriptor *old = NULL;
 	size_t sd_size = 0;
 	uint32_t i, j;
+	bool rv;
+	char *to_free = NULL;
 	NTSTATUS status;
 
 	if (mode != SMB_ACL_SET && mode != SMB_SD_DELETE) {
@@ -184,7 +192,15 @@ static int change_share_sec(TALLOC_CTX *mem_ctx, const char *sharename, char *th
 		/* should not happen */
 		return 0;
 	case SMB_ACL_VIEW:
-		sec_desc_print(NULL, stdout, old, false);
+		if (jsobj != NULL) {
+			rv = sec_desc_to_json(NULL, jsobj, old, false, true);
+			if (!rv) {
+				return -1;
+			}
+		}
+		else {
+			sec_desc_print(NULL, stdout, old, false);
+		}
 		return 0;
 	case SMB_ACL_DELETE:
 	    for (i=0;sd->dacl && i<sd->dacl->num_aces;i++) {
@@ -330,10 +346,13 @@ int main(int argc, const char *argv[])
 	int retval = 0;
 	enum acl_mode mode = SMB_ACL_SET;
 	static char *the_acl = NULL;
+	char *to_free = NULL;
 	fstring sharename;
 	bool force_acl = False;
+	bool do_json = False;
 	int snum;
 	poptContext pc;
+	struct json_object jsobj, jsint;
 	bool initialize_sid = False;
 	struct poptOption long_options[] = {
 		POPT_AUTOHELP
@@ -430,6 +449,14 @@ int main(int argc, const char *argv[])
 			.descrip    = "Force storing the ACL",
 			.argDescrip = "ACLS",
 		},
+		{
+			.longName   = "json",
+			.shortName  = 'j',
+			.argInfo    = POPT_ARG_NONE,
+			.arg        = NULL,
+			.val        = 'J',
+			.descrip    = "View ACL in JSON",
+		},
 		POPT_COMMON_SAMBA
 		POPT_TABLEEND
 	};
@@ -493,6 +520,10 @@ int main(int argc, const char *argv[])
 			force_acl = True;
 			break;
 
+		case 'J':
+			do_json = True;
+			break;
+
 		case 'M':
 			initialize_sid = True;
 			break;
@@ -531,6 +562,13 @@ int main(int argc, const char *argv[])
 
 	if (mode == SMB_ACL_VIEW_ALL) {
 		int i;
+		if (do_json) {
+			jsobj = json_new_object();
+			if (json_is_invalid(&jsobj)) {
+				fprintf(stderr, "Failed to generate valid JSON object\n");
+				goto done;
+			}
+		}
 
 		for (i=0; i<lp_numservices(); i++) {
 			TALLOC_CTX *frame = talloc_stackframe();
@@ -542,11 +580,29 @@ int main(int argc, const char *argv[])
 				continue;
 			}
 
-			printf("[%s]\n", service);
-			change_share_sec(frame, service, NULL, SMB_ACL_VIEW);
-			printf("\n");
+			if (do_json) {
+				change_share_sec(frame, service, NULL, SMB_ACL_VIEW, &jsint);
+				retval = json_add_object(&jsobj, service, &jsint);
+				if (retval != 0) {
+					fprintf(stderr,
+						"Failed to add JSON object for [%s]: %s\n",
+						service, strerror(errno));
+					goto done;
+				}
+			}
+			else {
+				printf("[%s]\n", service);
+				change_share_sec(frame, service, NULL, SMB_ACL_VIEW, NULL);
+				printf("\n");
+			}
 			TALLOC_FREE(frame);
 		}
+		if (do_json) {
+			to_free =  json_to_string(talloc_tos(), &jsobj);
+                        printf("%s", to_free);
+			TALLOC_FREE(to_free);
+			json_free(&jsobj);
+		}
 		goto done;
 	}
 
@@ -576,7 +632,7 @@ int main(int argc, const char *argv[])
 		retval = view_sharesec_sddl(sharename);
 		break;
 	default:
-		retval = change_share_sec(ctx, sharename, the_acl, mode);
+		retval = change_share_sec(ctx, sharename, the_acl, mode, NULL);
 		break;
 	}
 
diff --git a/source3/utils/smbcacls.c b/source3/utils/smbcacls.c
index 084df9f9a4a..93cde926801 100644
--- a/source3/utils/smbcacls.c
+++ b/source3/utils/smbcacls.c
@@ -32,6 +32,11 @@
 #include "passdb/machine_sid.h"
 #include "../librpc/gen_ndr/ndr_lsa_c.h"
 #include "util_sd.h"
+#ifdef HAVE_JANSSON
+#include <jansson.h>
+#include "audit_logging.h" /* various JSON helpers */
+#include "auth/common_auth.h"
+#endif /* [HAVE_JANSSON] */
 
 static int test_args;
 
@@ -418,6 +423,48 @@ static int cacl_dump(struct cli_state *cli, const char *filename, bool numeric)
 	return EXIT_OK;
 }
 
+static int cacl_dump_json(struct cli_state *cli, const char *filename, bool numeric)
+{
+	TALLOC_CTX *frame = talloc_stackframe();
+	struct security_descriptor *sd;
+	struct json_object jsobj;
+	int ret;
+
+	if (test_args) {
+		return EXIT_OK;
+	}
+
+	sd = get_secdesc(cli, filename);
+	if (sd == NULL) {
+		return EXIT_FAILED;
+	}
+
+	if (sddl) {
+		char *str = sddl_encode(talloc_tos(), sd, get_domain_sid(cli));
+		if (str == NULL) {
+			return EXIT_FAILED;
+		}
+		printf("%s\n", str);
+		TALLOC_FREE(str);
+	} else {
+		ret = sec_desc_to_json(cli, &jsobj, sd, numeric, false);
+		if (!ret) {
+			fprintf(stderr, "Failed to get secdesc_json\n");
+			TALLOC_FREE(frame);
+			return ret;
+		}
+		printf("%s", json_to_string(frame, &jsobj));
+	}
+	if (want_mxac) {
+		ret = cacl_mxac(cli, filename);
+		if (ret != EXIT_OK) {
+			return ret;
+		}
+	}
+	TALLOC_FREE(frame);
+	return EXIT_OK;
+}
+
 /***************************************************** 
 Change the ownership or group ownership of a file. Just
 because the NT docs say this can't be done :-). JRA.
@@ -813,6 +860,7 @@ int main(int argc, char *argv[])
 	int result;
 	char *path;
 	char *filename = NULL;
+	bool json_output = false;
 	poptContext pc;
 	/* numeric is set when the user wants numeric SIDs and ACEs rather
 	   than going via LSA calls to resolve them */
@@ -906,6 +954,14 @@ int main(int argc, char *argv[])
 			.val        = 1,
 			.descrip    = "The security-info flags for queries"
 		},
+		{
+			.longName   = "json-output",
+			.shortName  = 'j',
+			.argInfo    = POPT_ARG_NONE,
+			.arg        = NULL,
+			.val        = 'j',
+			.descrip    = "JSON output"
+		},
 		{
 			.longName   = "set-security-info",
 			.shortName  = 0,
@@ -1009,6 +1065,9 @@ int main(int argc, char *argv[])
 			owner_username = poptGetOptArg(pc);
 			change_mode = REQUEST_INHERIT;
 			break;
+		case 'j':
+			json_output = true;
+			break;
 		case 'm':
 			lp_set_cmdline("client max protocol", poptGetOptArg(pc));
 			break;
@@ -1086,6 +1145,8 @@ int main(int argc, char *argv[])
 		result = owner_set(cli, change_mode, filename, owner_username);
 	} else if (the_acl) {
 		result = cacl_set(cli, filename, the_acl, mode, numeric);
+	} else if (json_output) {
+		result = cacl_dump_json(cli, filename, numeric);
 	} else {
 		result = cacl_dump(cli, filename, numeric);
 	}
diff --git a/source3/utils/status.c b/source3/utils/status.c
index 36f7030e4f4..a7b5c733d1b 100644
--- a/source3/utils/status.c
+++ b/source3/utils/status.c
@@ -51,6 +51,12 @@
 #include "cmdline_contexts.h"
 #include "locking/leases_db.h"
 
+#ifdef HAVE_JANSSON
+#include <jansson.h>
+#include "audit_logging.h" /* various JSON helpers */
+#include "auth/common_auth.h"
+#endif /* [HAVE_JANSSON] */
+
 #define SMB_MAXPIDS		2048
 static uid_t 		Ucrit_uid = 0;               /* added by OH */
 static struct server_id	Ucrit_pid[SMB_MAXPIDS];  /* Ugly !!! */   /* added by OH */
@@ -64,9 +70,81 @@ static bool processes_only;
 static bool show_brl;
 static bool numeric_only;
 static bool do_checks = true;
+static bool json_output = false;
+static bool csv_output = false;
+static bool resolve_uids = false;
 
 const char *username = NULL;
 
+static const char *session_dialect_str(uint16_t dialect);
+
+#ifdef HAVE_JANSSON
+struct txt2mask {
+	char	*field;
+	int	mask;
+};
+
+struct txt2mask accessmask[] = {
+	{"READ_DATA", FILE_READ_DATA},
+	{"WRITE_DATA", FILE_WRITE_DATA},
+	{"APPEND_DATA", FILE_APPEND_DATA},
+	{"READ_EA", FILE_READ_EA},
+	{"WRITE_EA", FILE_WRITE_EA},
+	{"EXECUTE", FILE_EXECUTE},
+	{"READ_ATTRIBUTES", FILE_READ_ATTRIBUTES},
+	{"WRITE_ATTRIBUTES", FILE_WRITE_ATTRIBUTES},
+	{"DELETE_CHILD", FILE_DELETE_CHILD},
+	{"DELETE", SEC_STD_DELETE},
+	{"READ_CONTROL", SEC_STD_READ_CONTROL},
+	{"WRITE_DAC", SEC_STD_WRITE_DAC},
+	{"SYNCHRONIZE", SEC_STD_SYNCHRONIZE},
+	{"ACCESS_SYSTEM_SECURITY", SEC_FLAG_SYSTEM_SECURITY},
+	{"MAXIMUM_ALLOWED", SEC_FLAG_MAXIMUM_ALLOWED},
+	{"GENERIC_ALL", SEC_GENERIC_ALL},
+	{"GENERIC_EXECUTE", SEC_GENERIC_EXECUTE},
+	{"GENERIC_WRITE", SEC_GENERIC_WRITE},
+	{"GENERIC_READ", SEC_GENERIC_READ},
+	{0, 0}
+};
+
+struct txt2mask oplockmask[] = {
+	{"EXCLUSIVE", EXCLUSIVE_OPLOCK},
+	{"BATCH", BATCH_OPLOCK},
+	{"LEVEL_II", LEVEL_II_OPLOCK},
+	{"LEASE", LEASE_OPLOCK},
+	{0, 0}
+};
+
+struct txt2mask leasemask[] = {
+	{"READ", SMB2_LEASE_READ},
+	{"WRITE", SMB2_LEASE_WRITE},
+	{"HANDLE", SMB2_LEASE_HANDLE},
+	{0, 0}
+};
+
+/*
+ * Convert a mask of some sort (access, oplock, leases),
+ * to key/value pairs in a JSON object.
+ */
+static int map_json_mask(struct json_object *jsobj,
+                         int tomap,
+                         const struct txt2mask *table)
+{
+        const struct txt2mask *a;
+        int ret = 0;
+        for (a = table; a->field !=0; a++) {
+                if (json_add_bool(jsobj,
+                                  a->field,
+                                  (tomap & a->mask)
+                                  ?true:false) < 0){
+                        return -1;
+                }
+        }
+
+        return 0;
+}
+#endif /* [HAVE_JANSSON] */
+
 /* added by OH */
 static void Ucrit_addUid(uid_t uid)
 {
@@ -118,12 +196,634 @@ static bool Ucrit_addPid( struct server_id pid )
 	return True;
 }
 
+#ifdef HAVE_JANSSON
+static int print_share_mode_json(struct file_id fid,
+				 const struct share_mode_data *d,
+				 const struct share_mode_entry *e,
+				 void *private_data)
+{
+	TALLOC_CTX *tmp_ctx = talloc_new(NULL);
+	if (tmp_ctx == NULL) {
+		return -1;
+	}
+	struct json_object jsobj;
+	struct json_object jsobjint;
+	jsobj = *(struct json_object *)private_data;
+	jsobjint = json_new_object();
+	static int count;
+	const char *denymode = NULL;
+	char *access_mask = NULL;
+	const char *lstate_hex = NULL;
+
+	if (do_checks && !is_valid_share_mode_entry(e)) {
+		TALLOC_FREE(tmp_ctx);
+		json_free(&jsobjint);
+		return 0;
+	}
+
+	count++;
+
+	if (do_checks && !serverid_exists(&e->pid)) {
+		/* the process for this entry does not exist any more */
+		TALLOC_FREE(tmp_ctx);
+		json_free(&jsobjint);
+		return 0;
+	}
+	if (Ucrit_checkPid(e->pid)) {
+		struct server_id_buf tmp;
+		uint denymode_int = 0;
+		denymode_int = map_share_mode_to_deny_mode(e->share_access,
+							   e->private_options);
+
+		if (json_is_invalid(&jsobjint)) {
+			return -1;
+		}
+		if (json_add_string(&jsobjint, "pid",
+				    server_id_str_buf(e->pid, &tmp)) < 0) {
+			goto failure;
+		}
+		if (resolve_uids && (json_add_string(&jsobjint, "username",
+					    uidtoname(e->uid)) < 0)) {
+			goto failure;
+		}
+		if (json_add_int(&jsobjint, "uid", (unsigned int)e->uid) < 0) {
+			goto failure;
+		}
+		switch (denymode_int) {
+			case DENY_NONE: denymode = "DENY_NONE"; break;
+			case DENY_ALL:  denymode = "DENY_ALL"; break;
+			case DENY_DOS:  denymode = "DENY_DOS"; break;
+			case DENY_READ: denymode = "DENY_READ"; break;
+			case DENY_WRITE:denymode = "DENY_WRITE"; break;
+			case DENY_FCB:  denymode = "DENY_FCB"; break;
+			default: {
+				denymode = talloc_asprintf(tmp_ctx,
+							   "UNKNOWN(0x%08x)",
+							   denymode_int);
+				break;
+			}
+		}
+	        struct json_object amask;
+	        amask = json_new_object();
+		if (json_is_invalid(&amask)) {
+			goto failure;
+		}
+		access_mask = talloc_asprintf(tmp_ctx, "0x%08x",
+					      (unsigned int)e->access_mask);
+		if (json_add_string(&amask, "hex", access_mask) < 0) {
+			goto failure;
+		}
+		TALLOC_FREE(access_mask);
+		if (verbose) {
+			if (map_json_mask(&amask, e->access_mask, accessmask) < 0) {
+				json_free(&amask);
+				goto failure;
+			}
+		}
+		if (json_add_object(&jsobjint, "access_mask", &amask) < 0) {
+			json_free(&amask);
+			goto failure;
+		}
+
+		struct json_object oplock;
+		oplock = json_new_object();
+		if (json_is_invalid(&oplock)) {
+			goto failure;
+		}
+
+		struct txt2mask *o;
+		if (map_json_mask(&oplock, e->op_type, oplockmask) < 0) {
+			json_free(&amask);
+			goto failure;
+		}
+		if (json_add_object(&jsobjint, "oplock", &oplock) < 0) {
+			json_free(&oplock);
+			goto failure;
+		}
+
+		struct json_object lease;
+		lease = json_new_object();
+		if (json_is_invalid(&lease)) {
+			goto failure;
+		}
+		if (e->op_type & LEASE_OPLOCK) {
+			NTSTATUS status;
+			uint32_t lstate;
+
+			status = leases_db_get(
+				&e->client_guid,
+				&e->lease_key,
+				&d->id,
+				&lstate, /* current_state */
+				NULL, /* breaking */
+				NULL, /* breaking_to_requested */
+				NULL, /* breaking_to_required */
+				NULL, /* lease_version */
+				NULL); /* epoch */
+
+			if (NT_STATUS_IS_OK(status)) {
+				if (map_json_mask(&lease,
+						  lstate,
+						  leasemask) < 0) {
+					json_free(&lease);
+					goto failure;
+				}
+			}
+			if (lstate > SMB2_LEASE_WRITE) {
+				const char *lstate_hex;
+				lstate_hex = talloc_asprintf(tmp_ctx,
+							     "0x%04x",
+							     lstate);
+				if (json_add_bool(&lease,
+						  "UNKNOWN",
+						  lstate_hex) < 0) {
+					json_free(&lease);
+					goto failure;
+				}
+			}
+			if (json_add_object(&jsobjint, "lease", &lease) < 0) {
+				json_free(&lease);
+				goto failure;
+			}
+		}
+		else {
+			if (map_json_mask(&lease, 0, leasemask) < 0) {
+				json_free(&lease);
+				goto failure;
+			}
+			if (json_add_object(&jsobjint, "lease", &lease) < 0) {
+				json_free(&lease);
+				goto failure;
+			}
+		}
+		if (json_add_string(&jsobjint, "service_path", d->servicepath) < 0) {
+			goto failure;
+		}
+		char *filename = NULL;
+		filename = talloc_asprintf(tmp_ctx, "%s%s", d->base_name,
+			(d->stream_name != NULL) ? d->stream_name : "");
+		if (json_add_string(&jsobjint, "filename", filename) < 0) {
+			TALLOC_FREE(filename);
+			goto failure;
+		}
+		if (json_add_object(&jsobj, NULL, &jsobjint) < 0) {
+			goto failure;
+		}
+	}
+	TALLOC_FREE(tmp_ctx);
+	return 0;
+
+failure:
+	TALLOC_FREE(tmp_ctx);
+	json_free(&jsobjint);
+	return -1;
+}
+
+static void print_brl_json(struct file_id id,
+			struct server_id pid,
+			enum brl_type lock_type,
+			enum brl_flavour lock_flav,
+			br_off start,
+			br_off size,
+			void *private_data)
+{
+	struct json_object jsobj;
+	struct json_object jsobjint;
+	jsobj = *(struct json_object *)private_data;
+	jsobjint = json_new_object();
+	static int count;
+	unsigned int i;
+	static const struct {
+		enum brl_type lock_type;
+		const char *desc;
+	} lock_types[] = {
+		{ READ_LOCK, "R" },
+		{ WRITE_LOCK, "W" },
+		{ UNLOCK_LOCK, "U" }
+	};
+	const char *desc="X";
+	const char *sharepath = "";
+	char *fname = NULL;
+	struct share_mode_lock *share_mode;
+	struct server_id_buf tmp;
+	struct file_id_buf ftmp;
+
+	count++;
+
+	share_mode = fetch_share_mode_unlocked(NULL, id);
+	if (share_mode) {
+		bool has_stream = share_mode->data->stream_name != NULL;
+
+		fname = talloc_asprintf(NULL, "%s%s%s",
+					share_mode->data->base_name,
+					has_stream ? ":" : "",
+					has_stream ?
+					share_mode->data->stream_name :
+					"");
+	} else {
+		fname = talloc_strdup(NULL, "");
+		if (fname == NULL) {
+			return;
+		}
+	}
+
+	for (i=0;i<ARRAY_SIZE(lock_types);i++) {
+		if (lock_type == lock_types[i].lock_type) {
+			desc = lock_types[i].desc;
+		}
+	}
+	if (json_is_invalid(&jsobjint)) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "pid",
+			    server_id_str_buf(pid, &tmp)) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "dev_inode",
+			    file_id_str_buf(id, &ftmp)) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "read_write", desc) < 0) {
+		goto failure;
+	}
+	if (json_add_int(&jsobjint, "start", (intmax_t)start) < 0) {
+		goto failure;
+	}
+	if (json_add_int(&jsobjint, "size", (intmax_t)size) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "share_path", sharepath) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "file_name", fname) < 0) {
+		goto failure;
+	}
+	if (json_add_object(&jsobj, NULL, &jsobjint) < 0) {
+		goto failure;
+	}
+
+	TALLOC_FREE(fname);
+	TALLOC_FREE(share_mode);
+
+failure:
+	TALLOC_FREE(fname);
+	TALLOC_FREE(share_mode);
+	json_free(&jsobjint);
+}
+
+static int traverse_connections_json(const struct connections_key *key,
+				const struct connections_data *crec,
+				void *private_data)
+{
+	TALLOC_CTX *tmp_ctx = talloc_new(NULL);
+	if (tmp_ctx == NULL) {
+		return -1;
+	}
+	struct json_object jsobj;
+	struct json_object jsobjint;
+	jsobj = *(struct json_object *)private_data;
+	jsobjint = json_new_object();
+	struct server_id_buf tmp;
+	char *timestr = NULL;
+	int result = 0;
+	const char *encryption = "-";
+	const char *signing = "-";
+	if (json_is_invalid(&jsobjint)) {
+		TALLOC_FREE(tmp_ctx);
+		return -1;
+	}
+
+	if (crec->cnum == TID_FIELD_INVALID)
+		TALLOC_FREE(tmp_ctx);
+		json_free(&jsobjint);
+		return 0;
+
+	if (do_checks &&
+	    (!process_exists(crec->pid) || !Ucrit_checkUid(crec->uid))) {
+		TALLOC_FREE(tmp_ctx);
+		json_free(&jsobjint);
+		return 0;
+	}
+
+	timestr = timestring(tmp_ctx, crec->start);
+	if (timestr == NULL) {
+		goto failure;
+	}
+
+	if (smbXsrv_is_encrypted(crec->encryption_flags)) {
+		switch (crec->cipher) {
+		case SMB_ENCRYPTION_GSSAPI:
+			encryption = "GSSAPI";
+			break;
+		case SMB2_ENCRYPTION_AES128_CCM:
+			encryption = "AES-128-CCM";
+			break;
+		case SMB2_ENCRYPTION_AES128_GCM:
+			encryption = "AES-128-GCM";
+			break;
+		default:
+			encryption = talloc_asprintf(tmp_ctx,
+						     "UNKNOWN(0x%08x)",
+						     crec->cipher);
+			result = -1;
+			break;
+		}
+	}
+
+	if (smbXsrv_is_signed(crec->signing_flags)) {
+		switch (crec->dialect) {
+		case SMB3_DIALECT_REVISION_311:
+		case SMB3_DIALECT_REVISION_302:
+			signing = "AES-128-CMAC";
+			break;
+		case SMB2_DIALECT_REVISION_2FF:
+		case SMB2_DIALECT_REVISION_224:
+		case SMB2_DIALECT_REVISION_222:
+		case SMB2_DIALECT_REVISION_210:
+		case SMB2_DIALECT_REVISION_202:
+			signing = "HMAC-SHA256";
+			break;
+		case SMB2_DIALECT_REVISION_000:
+			signing = "HMAC-MD5";
+			break;
+		default:
+			signing = talloc_asprintf(tmp_ctx,
+						  "UNKNOWN_DIALECT(0x%08x)",
+						  crec->dialect);
+			result = -1;
+			break;
+		}
+	}
+
+	if (json_add_string(&jsobjint, "service", crec->servicename) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "pid",
+			    server_id_str_buf(crec->pid, &tmp)) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "machine", crec->machine) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "connected_at", timestr) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "encryption", encryption) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "signing", signing) < 0) {
+		goto failure;
+	}
+	if (json_add_object(&jsobj, NULL, &jsobjint) < 0) {
+		goto failure;
+	}
+
+	TALLOC_FREE(tmp_ctx);
+	return result;
+
+failure:
+	TALLOC_FREE(tmp_ctx);
+	json_free(&jsobjint);
+	return -1;
+}
+
+static int traverse_sessionid_json(const char *key, struct sessionid *session,
+				    void *private_data)
+{
+	TALLOC_CTX *tmp_ctx = talloc_new(NULL);
+	if (tmp_ctx == NULL) {
+		return -1;
+	}
+	struct json_object jsobj;
+	struct json_object jsobjint;
+	jsobj = *(struct json_object *)private_data;
+	jsobjint = json_new_object();
+	struct server_id_buf tmp;
+	int result = 0;
+	const char *encryption = "-";
+	const char *signing = "-";
+
+	if (do_checks &&
+	    (!process_exists(session->pid) ||
+	     !Ucrit_checkUid(session->uid))) {
+		return 0;
+	}
+
+	Ucrit_addPid(session->pid);
+
+	if (json_is_invalid(&jsobjint)) {
+		return -1;
+	}
+
+	if (json_add_int(&jsobjint, "uid",
+			 (unsigned int)session->uid) < 0) {
+		goto failure;
+	}
+	if (json_add_int(&jsobjint, "gid",
+			 (unsigned int)session->gid) < 0) {
+		goto failure;
+	}
+	if (!numeric_only) {
+		if (session->uid == -1 && session->gid == -1) {
+			/*
+			 * The session is not fully authenticated yet.
+			 */
+			if (json_add_string(&jsobjint, "username",
+					    "(auth in progress)") < 0) {
+				goto failure;
+			}
+			if (json_add_string(&jsobjint, "groupname",
+					    "(auth in progress)") < 0) {
+				goto failure;
+			}
+		} else {
+			/*
+			 * In theory it should not happen that one of
+			 * session->uid and session->gid is valid (ie != -1)
+			 * while the other is not (ie = -1), so we a check for
+			 * that case that bails out would be reasonable.
+			 */
+			const char *uid_name = "-1";
+			const char *gid_name = "-1";
+
+			if (session->uid != -1) {
+				uid_name = uidtoname(session->uid);
+				if (uid_name == NULL) {
+					return -1;
+				}
+			}
+			if (session->gid != -1) {
+				gid_name = gidtoname(session->gid);
+				if (gid_name == NULL) {
+					return -1;
+				}
+			}
+			if (json_add_string(&jsobjint, "username",
+					    uid_name) < 0) {
+				goto failure;
+			}
+			if (json_add_string(&jsobjint, "groupname",
+					    gid_name) < 0) {
+				goto failure;
+			}
+		}
+	}
+
+	if (smbXsrv_is_encrypted(session->encryption_flags)) {
+		switch (session->cipher) {
+		case SMB2_ENCRYPTION_AES128_CCM:
+			encryption = "AES-128-CCM";
+			break;
+		case SMB2_ENCRYPTION_AES128_GCM:
+			encryption = "AES-128-GCM";
+			break;
+		default:
+			encryption = talloc_asprintf(tmp_ctx,
+						     "UNKNOWN(0x%08x)",
+						     session->cipher);
+			result = -1;
+			break;
+		}
+	} else if (smbXsrv_is_partially_encrypted(session->encryption_flags)) {
+		switch (session->cipher) {
+		case SMB_ENCRYPTION_GSSAPI:
+			encryption = "partial(GSSAPI)";
+			break;
+		case SMB2_ENCRYPTION_AES128_CCM:
+			encryption = "partial(AES-128-CCM)";
+			break;
+		case SMB2_ENCRYPTION_AES128_GCM:
+			encryption = "partial(AES-128-GCM)";
+			break;
+		default:
+			encryption = talloc_asprintf(tmp_ctx,
+						     "UNKNOWN(0x%08x)",
+						     session->cipher);
+			result = -1;
+			break;
+		}
+	}
+
+	if (smbXsrv_is_signed(session->signing_flags)) {
+		switch (session->connection_dialect) {
+		case SMB3_DIALECT_REVISION_311:
+		case SMB3_DIALECT_REVISION_302:
+			signing = "AES-128-CMAC";
+			break;
+		case SMB2_DIALECT_REVISION_2FF:
+		case SMB2_DIALECT_REVISION_224:
+		case SMB2_DIALECT_REVISION_222:
+		case SMB2_DIALECT_REVISION_210:
+		case SMB2_DIALECT_REVISION_202:
+			signing = "HMAC-SHA256";
+			break;
+		case SMB2_DIALECT_REVISION_000:
+			signing = "HMAC-MD5";
+			break;
+		default:
+			signing = talloc_asprintf(tmp_ctx,
+						  "UNKNOWN_DIALECT(0x%08x)",
+						  session->connection_dialect);
+			result = -1;
+			break;
+		}
+	} else if (smbXsrv_is_partially_signed(session->signing_flags)) {
+		switch (session->connection_dialect) {
+		case SMB3_DIALECT_REVISION_311:
+		case SMB3_DIALECT_REVISION_302:
+			signing = "AES-128-CMAC";
+			break;
+		case SMB2_DIALECT_REVISION_2FF:
+		case SMB2_DIALECT_REVISION_224:
+		case SMB2_DIALECT_REVISION_222:
+		case SMB2_DIALECT_REVISION_210:
+		case SMB2_DIALECT_REVISION_202:
+			signing = "HMAC-SHA256";
+			break;
+		case SMB2_DIALECT_REVISION_000:
+			signing = "HMAC-MD5";
+			break;
+		default:
+			signing = talloc_asprintf(tmp_ctx,
+						  "UNKNOWN_DIALECT(0x%08x)",
+						  session->connection_dialect);
+			result = -1;
+			break;
+		}
+	}
+
+	if (json_add_string(&jsobjint, "remote_machine",
+			    session->remote_machine) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "hostname", session->hostname) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "session_dialect",
+		    session_dialect_str(session->connection_dialect)) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "encryption", encryption) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "signing", signing) < 0) {
+		goto failure;
+	}
+	if (json_add_object(&jsobj, server_id_str_buf(session->pid, &tmp), &jsobjint) < 0) {
+		goto failure;
+	}
+
+	TALLOC_FREE(tmp_ctx);
+	return result;
+
+failure:
+	TALLOC_FREE(tmp_ctx);
+	json_free(&jsobjint);
+	return -1;
+}
+
+static bool print_notify_rec_json(const char *path, struct server_id server,
+			     const struct notify_instance *instance,
+			     void *private_data)
+{
+	struct server_id_buf idbuf;
+	struct json_object jsobj;
+	struct json_object jsobjint;
+	jsobj = *(struct json_object *)private_data;
+	jsobjint = json_new_object();
+
+	if (json_is_invalid(&jsobjint)) {
+		return false;
+	}
+	if (json_add_string(&jsobjint, "pid", server_id_str_buf(server, &idbuf)) < 0) {
+		goto failure;
+	}
+	if (json_add_string(&jsobjint, "path", path) < 0) {
+		goto failure;
+	}
+	if (json_add_int(&jsobjint, "filter", (unsigned)instance->filter) < 0) {
+		goto failure;
+	}
+	if (json_add_int(&jsobjint, "subdir_filter", (unsigned)instance->subdir_filter) < 0) {
+		goto failure;
+	}
+	if (json_add_object(&jsobj, NULL, &jsobjint) < 0) {
+		goto failure;
+	}
+
+	return true;
+
+failure:
+	json_free(&jsobjint);
+	return false;
+}
+#endif /* [HAVE_JANSSON] */
+
 static int print_share_mode(struct file_id fid,
 			    const struct share_mode_data *d,
 			    const struct share_mode_entry *e,
 			    void *private_data)
 {
-	bool resolve_uids = *((bool *)private_data);
 	static int count;
 
 	if (do_checks && !is_valid_share_mode_entry(e)) {
@@ -510,7 +1210,6 @@ static int traverse_sessionid(const char *key, struct sessionid *session,
 	return result;
 }
 
-
 static bool print_notify_rec(const char *path, struct server_id server,
 			     const struct notify_instance *instance,
 			     void *private_data)
@@ -531,11 +1230,12 @@ enum {
 int main(int argc, const char *argv[])
 {
 	int c;
+	uint64_t interval = 1;
 	int profile_only = 0;
 	bool show_processes, show_locks, show_shares;
 	bool show_notify = false;
-	bool resolve_uids = false;
 	poptContext pc = NULL;
+	enum PROFILE_OUTPUT pout = PROF_TEXT;
 	struct poptOption long_options[] = {
 		POPT_AUTOHELP
 		{
@@ -610,6 +1310,14 @@ int main(int argc, const char *argv[])
 			.val        = 'R',
 			.descrip    = "Show call rates",
 		},
+		{
+			.longName   = "profile-timed-dump",
+			.shortName  = 'D',
+			.argInfo    = POPT_ARG_NONE,
+			.arg        = NULL,
+			.val        = 'D',
+			.descrip    = "Show call rates",
+		},
 		{
 			.longName   = "byterange",
 			.shortName  = 'B',
@@ -626,6 +1334,30 @@ int main(int argc, const char *argv[])
 			.val        = 'n',
 			.descrip    = "Numeric uid/gid"
 		},
+		{
+			.longName   = "json",
+			.shortName  = 'j',
+			.argInfo    = POPT_ARG_NONE,
+			.arg        = NULL,
+			.val        = 'j',
+			.descrip    = "JSON output"
+		},
+		{
+			.longName   = "csv",
+			.shortName  = 'c',
+			.argInfo    = POPT_ARG_NONE,
+			.arg        = NULL,
+			.val        = 'c',
+			.descrip    = "CSV output"
+		},
+		{
+			.longName   = "sample-interval",
+			.shortName  = 'i',
+			.argInfo    = POPT_ARG_INT,
+			.arg        = &interval,
+			.val        = 'i',
+			.descrip    = "CSV output"
+		},
 		{
 			.longName   = "fast",
 			.shortName  = 'f',
@@ -657,14 +1389,37 @@ int main(int argc, const char *argv[])
 	setup_logging(argv[0], DEBUG_STDERR);
 	lp_set_cmdline("log level", "0");
 
+	#ifdef HAVE_JANSSON
+	struct json_object jsobj = json_new_object();
+	#else /* [HAVE_JANSSON] */
+	if (json_output) {
+		fprintf(stderr, "JSON support not available\n");
+		goto done;
+	}
+	#endif /* [HAVE_JANSSON] */
+	if (json_output && csv_output) {
+		fprintf(stderr, "simultaneous CSV and json output not permitted\n");
+		goto done;
+	}
+
 	if (getuid() != geteuid()) {
-		d_printf("smbstatus should not be run setuid\n");
+		if (json_output) {
+			fprintf(stderr, "smbstatus should not be run setuid\n");
+		}
+		else {
+			d_printf("smbstatus should not be run setuid\n");
+		}
 		ret = 1;
 		goto done;
 	}
 
 	if (getuid() != 0) {
-		d_printf("smbstatus only works as root!\n");
+		if (json_output) {
+			fprintf(stderr, "smbstatus only works as root!\n");
+		}
+		else {
+			d_printf("smbstatus only works as root!\n");
+		}
 		ret = 1;
 		goto done;
 	}
@@ -696,6 +1451,7 @@ int main(int argc, const char *argv[])
 		case 'u':
 			Ucrit_addUid(nametouid(poptGetOptArg(pc)));
 			break;
+		case 'D':
 		case 'P':
 		case 'R':
 			profile_only = c;
@@ -706,6 +1462,16 @@ int main(int argc, const char *argv[])
 		case 'n':
 			numeric_only = true;
 			break;
+		case 'j':
+			json_output = true;
+			pout = PROF_JSON;
+			break;
+		case 'c':
+			csv_output = true;
+			pout = PROF_CSV;
+			break;
+		case 'i':
+			break;
 		case 'f':
 			do_checks = false;
 			break;
@@ -724,13 +1490,18 @@ int main(int argc, const char *argv[])
 	if ( username )
 		Ucrit_addUid( nametouid(username) );
 
-	if (verbose) {
+	if (verbose && !json_output) {
 		d_printf("using configfile = %s\n", get_dyn_CONFIGFILE());
 	}
 
 	msg_ctx = cmdline_messaging_context(get_dyn_CONFIGFILE());
 	if (msg_ctx == NULL) {
-		fprintf(stderr, "Could not initialize messaging, not root?\n");
+		if (json_output) {
+			fprintf(stderr, "Could not initialize messaging, not root?\n");
+		}
+		else {
+			fprintf(stderr, "Could not initialize messaging, not root?\n");
+		}
 		ret = -1;
 		goto done;
 	}
@@ -745,7 +1516,7 @@ int main(int argc, const char *argv[])
 	switch (profile_only) {
 		case 'P':
 			/* Dump profile data */
-			ok = status_profile_dump(verbose);
+			ok = status_profile_dump(verbose, pout);
 			ret = ok ? 0 : 1;
 			goto done;
 		case 'R':
@@ -753,16 +1524,41 @@ int main(int argc, const char *argv[])
 			ok = status_profile_rates(verbose);
 			ret = ok ? 0 : 1;
 			goto done;
+		case 'D':
+			/* Continuously display profile dump (Big D)*/
+			fprintf(stderr, "Sampling interval: %lu\n", interval);
+			ok = status_profile_timed_dump(verbose, pout, interval);
+			ret = ok ? 0 : 1;
+			goto done;
 		default:
 			break;
 	}
 
 	if ( show_processes ) {
-		d_printf("\nSamba version %s\n",samba_version_string());
-		d_printf("%-7s %-12s %-12s %-41s %-17s %-20s %-21s\n", "PID", "Username", "Group", "Machine", "Protocol Version", "Encryption", "Signing");
-		d_printf("----------------------------------------------------------------------------------------------------------------------------------------\n");
+		if (!json_output) {
+			d_printf("\nSamba version %s\n",samba_version_string());
+			d_printf("%-7s %-12s %-12s %-41s %-17s %-20s %-21s\n", "PID", "Username", "Group", "Machine", "Protocol Version", "Encryption", "Signing");
+			d_printf("----------------------------------------------------------------------------------------------------------------------------------------\n");
+			sessionid_traverse_read(traverse_sessionid, frame);
+		}
+		#ifdef HAVE_JANSSON
+		else {
+			struct json_object sessions = json_new_object();
+			if (json_is_invalid(&sessions)) {
+				fprintf(stderr, "Failed to create JSON object [sessions]\n");
+				ret = -1;
+				goto done;
+			}
 
-		sessionid_traverse_read(traverse_sessionid, frame);
+			sessionid_traverse_read(traverse_sessionid_json, &sessions);
+			if (json_add_object(&jsobj, "sessions", &sessions) < 0) {
+				fprintf(stderr, "Failed to add JSON object [sessions]\n");
+				json_free(&sessions);
+				ret = -1;
+				goto done;
+			}
+		}
+		#endif /* [HAVE_JANSSON] */
 
 		if (processes_only) {
 			goto done;
@@ -774,12 +1570,32 @@ int main(int argc, const char *argv[])
 			goto done;
 		}
 
-		d_printf("\n%-12s %-7s %-13s %-32s %-12s %-12s\n", "Service", "pid", "Machine", "Connected at", "Encryption", "Signing");
-		d_printf("---------------------------------------------------------------------------------------------\n");
-
-		connections_forall_read(traverse_connections, frame);
+		if (!json_output) {
+			d_printf("\n%-12s %-7s %-13s %-32s %-12s %-12s\n", "Service", "pid", "Machine", "Connected at", "Encryption", "Signing");
+			d_printf("---------------------------------------------------------------------------------------------\n");
+			connections_forall_read(traverse_connections, frame);
+		}
+		#ifdef HAVE_JANSSON
+		else {
+			struct json_object shares_array = json_new_array();
+			if (json_is_invalid(&shares_array)) {
+				fprintf(stderr, "Failed to create JSON array [shares_array]\n");
+				ret = 1;
+				goto done;
+			}
+			connections_forall_read(traverse_connections_json, &shares_array);
+			if (json_add_object(&jsobj, "shares", &shares_array) < 0) {
+				fprintf(stderr, "Failed to add JSON array [shares_array]\n");
+				json_free(&shares_array);
+				ret = -1;
+				goto done;
+			}
 
-		d_printf("\n");
+			if (!json_output) {
+				d_printf("\n");
+			}
+		}
+		#endif /* [HAVE_JANSSON] */
 
 		if ( shares_only ) {
 			goto done;
@@ -792,7 +1608,12 @@ int main(int argc, const char *argv[])
 
 		db_path = lock_path(talloc_tos(), "locking.tdb");
 		if (db_path == NULL) {
-			d_printf("Out of memory - exiting\n");
+			if (json_output) {
+				fprintf(stderr, "Out of memory - exiting\n");
+			}
+			else {
+				d_printf("Out of memory - exiting\n");
+			}
 			ret = -1;
 			goto done;
 		}
@@ -802,9 +1623,16 @@ int main(int argc, const char *argv[])
 			     DBWRAP_LOCK_ORDER_1, DBWRAP_FLAG_NONE);
 
 		if (!db) {
-			d_printf("%s not initialised\n", db_path);
-			d_printf("This is normal if an SMB client has never "
-				 "connected to your server.\n");
+			if (json_output) {
+				fprintf(stderr, "%s not initialised\n", db_path);
+				fprintf(stderr, "This is normal if an SMB client has never "
+					 "connected to your server.\n");
+			}
+			else {
+				d_printf("%s not initialised\n", db_path);
+				d_printf("This is normal if an SMB client has never "
+					 "connected to your server.\n");
+			}
 			TALLOC_FREE(db_path);
 			exit(0);
 		} else {
@@ -817,20 +1645,66 @@ int main(int argc, const char *argv[])
 			ret = 1;
 			goto done;
 		}
-
-		result = share_entry_forall(print_share_mode, &resolve_uids);
+		if (!json_output) {
+			result = share_entry_forall(print_share_mode, NULL);
+		}
+		#if HAVE_JANSSON
+		else {
+			struct json_object locks_array = json_new_array();
+			if (json_is_invalid(&locks_array)) {
+				locking_end();
+				fprintf(stderr, "Failed to create JSON array [locks_array]\n");
+				ret = 1;
+				goto done;
+			}
+			result = share_entry_forall(print_share_mode_json, &locks_array);
+			if (json_add_object(&jsobj, "locked_files", &locks_array) < 0) {
+				locking_end();
+				fprintf(stderr, "Failed to add JSON array [locks_array]\n");
+				ret = 1;
+				goto done;
+			}
+		}
+		#endif /* [HAVE_JANSSON] */
 
 		if (result == 0) {
-			d_printf("No locked files\n");
+			if (!json_output) {
+				d_printf("No locked files\n");
+			}
 		} else if (result < 0) {
-			d_printf("locked file list truncated\n");
+			if (json_output) {
+				fprintf(stderr, "locked file list truncated\n");
+			}
+			else {
+				d_printf("locked file list truncated\n");
+			}
 		}
 
-		d_printf("\n");
+		if (!json_output) {
+			d_printf("\n");
+		}
 
-		if (show_brl) {
+		if (show_brl && !json_output) {
 			brl_forall(print_brl, NULL);
 		}
+		#if HAVE_JANSSON
+		else if (show_brl) {
+			struct json_object brl_array = json_new_array();
+			if (json_is_invalid(&brl_array)) {
+				locking_end();
+				fprintf(stderr, "Failed to create JSON array [brl_array]\n");
+				ret = 1;
+				goto done;
+			}
+			brl_forall(print_brl_json, &brl_array);
+			if (json_add_object(&jsobj, "brl", &brl_array) < 0) {
+				locking_end();
+				fprintf(stderr, "Failed to add JSON array [brl_array]\n");
+				ret = 1;
+				goto done;
+			}
+		}
+		#endif /* [HAVE_JANSSON] */
 
 		locking_end();
 	}
@@ -843,12 +1717,38 @@ int main(int argc, const char *argv[])
 		if (n == NULL) {
 			goto done;
 		}
-		notify_walk(n, print_notify_rec, NULL);
+		if (!json_output) {
+			notify_walk(n, print_notify_rec, NULL);
+		}
+		#if HAVE_JANSSON
+		else {
+			struct json_object notify_array = json_new_array();
+			if (json_is_invalid(&notify_array)) {
+				locking_end();
+				fprintf(stderr, "Failed to create JSON array [notify_array]\n");
+				ret = 1;
+				goto done;
+			}
+			notify_walk(n, print_notify_rec_json, &notify_array);
+			if (json_add_object(&jsobj, "notify", &notify_array) < 0) {
+				locking_end();
+				fprintf(stderr, "Failed to add JSON array [notify_array]\n");
+				ret = 1;
+				goto done;
+			}
+		}
+		#endif /* [HAVE_JANSSON] */
 		TALLOC_FREE(n);
 	}
 
 done:
 	poptFreeContext(pc);
+	#ifdef HAVE_JANSSON
+	if (json_output && !profile_only) {
+		d_printf("%s\n", json_to_string(frame, &jsobj));
+	}
+	json_free(&jsobj);
+	#endif /* [HAVE_JANSSON] */
 	TALLOC_FREE(frame);
 	return ret;
 }
diff --git a/source3/utils/status_profile.c b/source3/utils/status_profile.c
index 829e84cef1c..5f6a9db855d 100644
--- a/source3/utils/status_profile.c
+++ b/source3/utils/status_profile.c
@@ -21,43 +21,130 @@
 #include "includes.h"
 #include "smbprofile.h"
 #include "status_profile.h"
+#include <jansson.h>
+#include "audit_logging.h" /* various JSON helpers */
+#include "auth/common_auth.h"
 
-static void profile_separator(const char * title)
-{
-    char line[79 + 1];
-    char * end;
-
-    snprintf(line, sizeof(line), "**** %s ", title);
+static bool first_done;
+static bool header_complete;
 
-    for (end = line + strlen(line); end < &line[sizeof(line) -1]; ++end) {
-	    *end = '*';
-    }
+static void profile_separator(const char * title, struct json_object jsobj,
+			      struct json_object *jo, enum PROFILE_OUTPUT proft)
+{
+	int ret;
+	size_t tlen;
+	char l[80] = {0};
+	char * end;
+	switch (proft) {
+	case PROF_TEXT:
+		snprintf(l, sizeof(l), "**** %s ", title);
+
+		for (end = l + strlen(l); end < &l[sizeof(l) -1]; ++end) {
+			*end = '*';
+		}
 
-    line[sizeof(line) - 1] = '\0';
-    d_printf("%s\n", line);
+		l[sizeof(l) - 1] = '\0';
+		d_printf("%s\n", l);
+		break;
+	case PROF_JSON:
+		tlen = strlen(title);
+		SMB_ASSERT(tlen < 80);
+		memcpy(l, title + 1, (tlen -2));
+
+		*jo = json_new_object();
+		if (json_is_invalid(jo)) {
+			fprintf(stderr, "jo is invalid JSON\n");
+			return;
+		}
+		ret = json_add_object(&jsobj, l, jo);
+		if (ret != 0) {
+			fprintf(stderr, "failed to add new json object: %s\n",
+				title);
+		}
+		break;
+	case PROF_CSV:
+		break;
+	}
+	return;
 }
 
 /*******************************************************************
  dump the elements of the profile structure
   ******************************************************************/
-bool status_profile_dump(bool verbose)
+bool status_profile_dump(bool verbose,  enum PROFILE_OUTPUT proft)
 {
+	TALLOC_CTX *mem_ctx = NULL;
+	int ret;
 	struct profile_stats stats = {};
+	struct json_object jo, jsobj;
+	bool json, csv;
+	char fname[80] = {0};
+	char elem[3] = {0};
+	char csvout[1024] = {0};
+	struct timeval tv;
 
 	if (!profile_setup(NULL, True)) {
 		fprintf(stderr,"Failed to initialise profile memory\n");
 		return False;
 	}
+	if (proft == PROF_JSON) {
+		mem_ctx = talloc_new(NULL);
+		if (mem_ctx == NULL) {
+			fprintf(stderr, "talloc_new() failed\n");
+			return False;
+		}
+		jsobj = json_new_object();
+		if (json_is_invalid(&jsobj)) {
+			fprintf(stderr, "jsobj is invalid\n");
+			return False;
+		}
+		ret = json_add_timestamp(&jsobj);
+		if (ret < 0) {
+			fprintf(stderr, "Failed to add timestamp to JSON.\n");
+			json_free(&jsobj);
+			return False;
+		}
+	}
 
 	smbprofile_collect(&stats);
 
 #define __PRINT_FIELD_LINE(name, _stats, field) do { \
-	d_printf("%-59s%20ju\n", \
-		 name "_" #field ":", \
-		 (uintmax_t)stats.values._stats.field); \
+	uintmax_t val = (uintmax_t)stats.values._stats.field; \
+	if (proft == PROF_JSON) { \
+		snprintf(fname, sizeof(fname), "%s_%s", name, #field); \
+		if (json_add_int(&jo, fname, val) < 0) { \
+			json_free(&jsobj); \
+			return False; \
+		} \
+	} \
+	else if (proft == PROF_CSV) { \
+		if (!header_complete) { \
+			if (!first_done) { \
+				printf("timestamp"); \
+				gettimeofday(&tv, NULL); \
+				snprintf(csvout, sizeof(csvout), "%ld", tv.tv_sec); \
+			} \
+			printf(",%s_%s", name, #field); \
+			snprintf(elem, sizeof(elem), ",%lu", val); \
+		} \
+		else { \
+			if (!first_done) { \
+				gettimeofday(&tv, NULL); \
+				snprintf(csvout, sizeof(csvout), "%ld", tv.tv_sec); \
+			} \
+			snprintf(elem, sizeof(elem), ",%lu", val); \
+		} \
+		first_done = True; \
+		strncat(csvout, elem, sizeof(csvout) - strlen(csvout) - 1); \
+	} \
+	else {\
+		d_printf("%-59s%20ju\n", \
+			 name "_" #field ":", \
+			 val); \
+	}\
 } while(0);
 #define SMBPROFILE_STATS_START
-#define SMBPROFILE_STATS_SECTION_START(name, display) profile_separator(#display);
+#define SMBPROFILE_STATS_SECTION_START(name, display) profile_separator(#display, jsobj, &jo, proft);
 #define SMBPROFILE_STATS_COUNT(name) do { \
 	__PRINT_FIELD_LINE(#name, name##_stats,  count); \
 } while(0);
@@ -95,6 +182,19 @@ bool status_profile_dump(bool verbose)
 #undef SMBPROFILE_STATS_SECTION_END
 #undef SMBPROFILE_STATS_END
 
+	first_done = False;
+	if (proft == PROF_JSON) {
+		printf("%s\n", json_to_string(mem_ctx, &jsobj));
+		TALLOC_FREE(mem_ctx);
+		json_free(&jsobj);
+	}
+	else if (proft == PROF_CSV) {
+		if (!header_complete) {
+			printf("\n");
+		}
+		printf("%s\n", csvout);
+	}
+	header_complete = True;
 	return True;
 }
 
@@ -361,3 +461,41 @@ bool status_profile_rates(bool verbose)
 
 	return True;
 }
+
+bool status_profile_timed_dump(bool verbose, enum PROFILE_OUTPUT proft, uint64_t sample_interval)
+{
+	uint64_t remain_usec;
+	uint64_t next_usec;
+	uint64_t delta_usec;
+	uint64_t interval;
+	bool ret;
+	int last = 0;
+	int current = 1;
+	int tmp;
+	interval = sample_interval * one_second_usec;
+
+	for (;/*ever*/;) {
+		sample_time[current] = profile_timestamp();
+		next_usec = sample_time[current] + interval;
+		ret = status_profile_dump(verbose, proft);
+		if (!ret) {
+			fprintf(stderr, "Timed dump failed\n");
+			return False;
+		}
+		last = current;
+		current = tmp;
+		ret = fflush(stdout);
+		if (ret != 0) {
+			fprintf(stderr, "Failed to flush output stream: %s\n",
+				strerror(errno));
+			return False;
+		}
+		remain_usec = next_usec - profile_timestamp();
+		if (remain_usec > interval) {
+			fprintf(stderr, "eek! falling behind sampling rate!\n");
+		} else {
+			usleep(remain_usec);
+		}
+	}
+	return True;
+}
diff --git a/source3/utils/status_profile.h b/source3/utils/status_profile.h
index a8a73e12178..485a55e6d2a 100644
--- a/source3/utils/status_profile.h
+++ b/source3/utils/status_profile.h
@@ -21,8 +21,10 @@
 #define __STATUS_PROFILE_H__
 
 #include "replace.h"
+enum PROFILE_OUTPUT {PROF_TEXT, PROF_CSV, PROF_JSON};
 
-bool status_profile_dump(bool be_verbose);
+bool status_profile_dump(bool be_verbose, enum PROFILE_OUTPUT proft);
 bool status_profile_rates(bool be_verbose);
+bool status_profile_timed_dump(bool be_verbose, enum PROFILE_OUTPUT proft, uint64_t sample_interval);
 
 #endif
