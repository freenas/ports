diff --git a/source3/modules/smb_libzfs.c b/source3/modules/smb_libzfs.c
new file mode 100644
index 00000000000..e1a4bfc9334
--- /dev/null
+++ b/source3/modules/smb_libzfs.c
@@ -0,0 +1,1403 @@
+/*-
+ * Copyright 2018 iXsystems, Inc.
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <stdbool.h>
+#include <talloc.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/nvpair.h>
+#include <libzfs.h>
+#include <fnmatch.h>
+#include "lib/util/debug.h"
+#include "lib/util/dlinklist.h"
+#include "lib/util/memcache.h"
+#include "smb_macros.h"
+#include "includes.h"
+#include "modules/smb_libzfs.h"
+#include "smbd/globals.h"
+#include "smbd/smbd.h"
+
+#ifndef SAFE_FREE
+#define SAFE_FREE(x) do { if ((x) != NULL) {free(x); (x)=NULL;} } while(0)
+#endif
+
+#define SHADOW_COPY_ZFS_GMT_FORMAT "@GMT-%Y.%m.%d-%H.%M.%S"
+#define ZFS_PROP_SAMBA_PREFIX "org.samba"
+
+static struct enum_list casesensitivity[] = {
+	{SMBZFS_SENSITIVE, "sensitive"},
+	{SMBZFS_INSENSITIVE, "insensitive"},
+	{SMBZFS_MIXED, "mixed"},
+	{ -1, NULL}
+};
+
+struct smblibzfs_int {
+	libzfs_handle_t *libzfsp;
+};
+
+struct smbzhandle_int {
+	zfs_handle_t *zhandle;
+};
+
+struct iter_info
+{
+	bool ignore_empty_snaps;
+	const char **inclusions;
+	const char **exclusions;
+	time_t start;
+	time_t end;
+};
+
+struct snap_cb
+{
+	struct snapshot_list *snapshots;
+	struct iter_info *iter_info;
+	int prev_u;
+	int prev_prev_u;
+};
+
+struct child_cb
+{
+	struct dataset_list *dslist;
+	bool open_zhandle;
+};
+
+static int get_enum(const char *s, const struct enum_list *_enum)
+{
+	int i;
+
+	if (!s || !*s || !_enum) {
+		return (-1);
+	}
+
+	for (i=0; _enum[i].name; i++) {
+		if (strcmp(_enum[i].name,s) == 0)
+			return _enum[i].value;
+	}
+
+	DBG_ERR("get_enum(%s,enum): value is not in enum_list!\n", s);
+	return (-1);
+}
+
+static int smblibzfs_handle_destructor(struct smblibzfs_int *slibzp)
+{
+	if (slibzp->libzfsp == NULL) {
+		DBG_ERR("Failed to retrieve libzfs handle"
+			"from smblibzfs handle\n");
+		return 0; //proceed with freeing memory. Nothing we can do here.
+	}
+	libzfs_fini(slibzp->libzfsp);
+	return 0;
+}
+
+static int smbzhandle_destructor(struct smbzhandle_int *szhp)
+{
+	if (szhp->zhandle == NULL) {
+		DBG_INFO("Failed to retrieve smb zfs dataset handle"
+			"from smbzhandle\n");
+		return 0; //proceed with freeing memory. Nothing we can do here.
+	}
+	zfs_close(szhp->zhandle);
+	return 0;
+}
+
+int get_smblibzfs_handle(TALLOC_CTX *mem_ctx, struct smblibzfshandle **smblibzfsp)
+{
+	libzfs_handle_t *libzfsp = NULL;
+	struct smblibzfs_int *slibzp_int = NULL;
+	struct smblibzfshandle *slibzp_ext = NULL;
+	slibzp_ext = talloc_zero(mem_ctx, struct smblibzfshandle);
+	if (slibzp_ext == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+	slibzp_int = talloc_zero(slibzp_ext, struct smblibzfs_int);
+	if (slibzp_int == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+	libzfsp = libzfs_init();
+	if (libzfsp == NULL) {
+		DBG_ERR("Failed to init libzfs\n");
+		return -1;
+	}
+	libzfs_print_on_error(libzfsp, B_TRUE);
+	slibzp_int->libzfsp = libzfsp;
+	talloc_set_destructor(slibzp_int, smblibzfs_handle_destructor);
+	slibzp_ext->sli = slibzp_int;
+	slibzp_ext->zcache = memcache_init(slibzp_ext, (1024 * 1024));
+	*smblibzfsp = slibzp_ext;
+	return 0;
+}
+
+static zfs_handle_t *get_zhandle(struct smblibzfshandle *smblibzfsp,
+				 const char *path)
+{
+	/* "path" here can be either mountpoint or dataset name */
+	zfs_handle_t *zfsp = NULL;
+
+	if (smblibzfsp->sli == NULL) {
+		DBG_ERR("Failed to retrieve smblibzfs_int handle\n");
+		return zfsp;
+	}
+
+	if (path == NULL) {
+		DBG_ERR("No pathname provided\n");
+		return zfsp;
+	}
+
+	zfsp = zfs_path_to_zhandle(smblibzfsp->sli->libzfsp, path,
+		ZFS_TYPE_VOLUME|ZFS_TYPE_DATASET|ZFS_TYPE_FILESYSTEM);
+
+	if (zfsp == NULL) {
+		DBG_ERR("Failed to obtain zhandle on parent directory: (%s)\n",
+			path);
+	}
+	return zfsp;
+}
+
+static zfs_handle_t *get_zhandle_from_smbzhandle(struct smbzhandle *smbzhandle)
+{
+	if (!smbzhandle->is_open) {
+		DBG_ERR("zhandle is closed!\n");
+		errno = EINVAL;
+		return NULL;
+	}
+	return smbzhandle->zhp->zhandle;
+}
+
+int get_smbzhandle(struct smblibzfshandle *smblibzfsp,
+		         TALLOC_CTX *mem_ctx, char *path,
+                         struct smbzhandle **smbzhandle)
+{
+	zfs_handle_t *zfsp = NULL;
+	struct smbzhandle_int *szhandle_int = NULL;
+	struct smbzhandle *szhandle_ext = NULL;
+	zfsp = get_zhandle(smblibzfsp, path);
+
+	if (zfsp == NULL) {
+		DBG_ERR("Failed to obtain zhandle on parent directory: (%s)\n",
+			path);
+		return -1;
+	}
+	szhandle_int = talloc_zero(mem_ctx, struct smbzhandle_int);
+	if (szhandle_int == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+	szhandle_ext = talloc_zero(mem_ctx, struct smbzhandle);
+	if (szhandle_ext == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+	szhandle_int->zhandle = zfsp;
+	szhandle_ext->is_open = true;
+	szhandle_ext->zhp = szhandle_int;
+	szhandle_ext->lz = smblibzfsp;
+	*smbzhandle = szhandle_ext;
+	return 0;
+}
+
+void close_smbzhandle(struct smbzhandle *zfsp_ext)
+{
+	if (!zfsp_ext->is_open) {
+		return;
+	}
+	zfs_handle_t *zfsp_int = NULL;
+	zfsp_int = get_zhandle_from_smbzhandle(zfsp_ext);
+	if (!zfsp_int) {
+		DBG_ERR("failed to get zhandle\n");
+		zfsp_ext->is_open = false;
+		return;
+	}
+	zfs_close(zfsp_int);
+	zfsp_int = NULL;
+	zfsp_ext->is_open = false;
+	return;
+}
+
+int
+smb_zfs_path_to_dataset(struct smblibzfshandle *smblibzfsp,
+			const char *pathname,
+			const char **dataset_name_out)
+{
+	zfs_handle_t *zfsp = NULL;
+	zfsp = get_zhandle(smblibzfsp, pathname);
+
+	if (zfsp == NULL) {
+		DBG_ERR("Failed to obtain zhandle on parent directory: (%s)\n",
+			pathname);
+		return -1;
+	}
+
+	*dataset_name_out = zfs_get_name(zfsp);
+	zfs_close(zfsp);
+	return 0;
+}
+
+int
+smb_get_dataset_name(struct smbzhandle *zhandle_ext, const char **dataset_name_out)
+{
+	int ret;
+	struct smbzhandle_int *zfsp_int = NULL;
+	zfs_handle_t *zfsp = NULL;
+	zfsp = get_zhandle_from_smbzhandle(zhandle_ext);
+	if (!zfsp) {
+		return -1;
+	}
+	*dataset_name_out = zfs_get_name(zfsp);
+	return 0;
+}
+
+int
+smb_zfs_dataset_name_to_mp(struct smblibzfshandle *smblibzfsp,
+			   TALLOC_CTX *mem_ctx,
+			   const char *dataset_name,
+			   char **dataset_mp_out)
+{
+	int ret;
+	zfs_handle_t *zfsp = NULL;
+	*dataset_mp_out = talloc_zero_size(mem_ctx, PATH_MAX);
+	if (*dataset_mp_out == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+	if (smblibzfsp->sli == NULL) {
+		DBG_ERR("Failed to retrieve smblibzfs_int handle\n");
+		return -1;
+	}
+	zfsp = zfs_open(smblibzfsp->sli->libzfsp, dataset_name, ZFS_TYPE_DATASET);
+	if (zfsp == NULL) {
+		DBG_ERR("Failed to get zfs handle for %s: %s\n",
+			dataset_name, strerror(errno));
+		return -1;
+	}
+	ret = zfs_prop_get(zfsp, ZFS_PROP_MOUNTPOINT, *dataset_mp_out,
+			   talloc_get_size(*dataset_mp_out), NULL, NULL,
+			   0, 0);
+	if (ret != 0) {
+		DBG_ERR("Failed to get mountpoint for %s: %s\n",
+			dataset_name, strerror(errno));
+		zfs_close(zfsp);
+		return -1;
+	}
+	zfs_close(zfsp);
+	return 0;
+}
+
+int
+smb_zfs_get_userspace_quota(struct smblibzfshandle *smblibzfsp,
+		  char *path, int64_t xid,
+		  enum SMB_QUOTA_TYPE quota_type,
+		  uint64_t *hardlimit, uint64_t *usedspace)
+{
+	int ret;
+	size_t blocksize = 1024;
+	zfs_handle_t *zfsp = NULL;
+	char u_req[ZFS_MAXPROPLEN] = { 0 };
+	char q_req[ZFS_MAXPROPLEN] = { 0 };
+	uint64_t quota, used;
+	quota = used = 0;
+	if (smblibzfsp->sli == NULL) {
+		DBG_ERR("Failed to retrieve smblibzfs_int handle\n");
+		return -1;
+	}
+
+	DBG_DEBUG("Path: (%s), xid: %lu), qtype (%u)\n",
+		path, xid, quota_type);
+
+	switch (quota_type) {
+	case SMB_USER_QUOTA_TYPE:
+	case SMB_USER_FS_QUOTA_TYPE:
+		snprintf(u_req, sizeof(u_req), "userused@%lu", xid);
+		snprintf(q_req, sizeof(q_req), "userquota@%lu", xid);
+		DBG_DEBUG("u_req: (%s), q_req (%s)\n", u_req, q_req);
+		break;
+	case SMB_GROUP_QUOTA_TYPE:
+	case SMB_GROUP_FS_QUOTA_TYPE:
+		snprintf(u_req, sizeof(u_req), "groupused@%lu", xid);
+		snprintf(q_req, sizeof(q_req), "groupquota@%lu", xid);
+		DBG_DEBUG("u_req: (%s), q_req (%s)\n", u_req, q_req);
+		break;
+	default:
+		DBG_ERR("Received unknown quota type (%d)\n", quota_type);
+		return (-1);
+	}
+
+	if (path == NULL) {
+		DBG_ERR("Path does not exist\n");
+		return (-1);
+	}
+
+	zfsp = zfs_path_to_zhandle(smblibzfsp->sli->libzfsp, path,
+		ZFS_TYPE_VOLUME|ZFS_TYPE_DATASET|ZFS_TYPE_FILESYSTEM);
+
+	if (zfsp == NULL) {
+		DBG_ERR("Failed to convert path (%s) to zhandle\n", path);
+		return (-1);
+	}
+
+	zfs_prop_get_userquota_int(zfsp, q_req, &quota);
+	zfs_prop_get_userquota_int(zfsp, u_req, &used);
+
+	zfs_close(zfsp);
+
+	quota /= blocksize;
+	used /= blocksize;
+
+	*hardlimit = quota;
+	*usedspace = used;
+
+	return 0;
+}
+
+int
+smb_zfs_set_userspace_quota(struct smblibzfshandle *smblibzfsp,
+		  char *path, int64_t xid,
+		  enum SMB_QUOTA_TYPE quota_type,
+		  uint64_t hardlimit)
+{
+	size_t blocksize = 1024;
+	zfs_handle_t *zfsp = NULL;
+	char q_req[256] = { 0 };
+	char quota[256] = { 0 };
+	hardlimit *= blocksize;
+	snprintf(quota, sizeof(quota), "%lu", hardlimit);
+	if (smblibzfsp->sli == NULL) {
+		DBG_ERR("Failed to retrieve smblibzfs_int handle\n");
+		return -1;
+	}
+
+	DBG_DEBUG("Path: (%s), xid: %lu), qtype (%u), limit (%lu)\n",
+		path, xid, quota_type, hardlimit);
+	switch (quota_type) {
+	case SMB_USER_QUOTA_TYPE:
+	case SMB_USER_FS_QUOTA_TYPE:
+		snprintf(q_req, sizeof(q_req), "userquota@%lu", xid);
+		DBG_DEBUG("userquota string is (%s)\n", q_req);
+		break;
+	case SMB_GROUP_QUOTA_TYPE:
+	case SMB_GROUP_FS_QUOTA_TYPE:
+		snprintf(q_req, sizeof(q_req), "groupquota@%lu", xid);
+		DBG_DEBUG("groupquota string is (%s)\n", q_req);
+		break;
+	default:
+		DBG_ERR("Received unknown quota type (%d)\n", quota_type);
+		return (-1);
+	}
+
+	if (path == NULL) {
+		DBG_ERR("smb_zfs_set_quota received NULL path\n");
+		return (-1);
+	}
+
+	zfsp = zfs_path_to_zhandle(smblibzfsp->sli->libzfsp, path,
+		ZFS_TYPE_VOLUME|ZFS_TYPE_DATASET|ZFS_TYPE_FILESYSTEM);
+
+	if (zfsp == NULL){
+		DBG_ERR("Failed to convert path (%s) to zhandle\n", path);
+		return (-1);
+	}
+
+	if (zfs_prop_set(zfsp, q_req, quota) != 0) {
+		DBG_ERR("Failed to set (%s = %s)\n", q_req, quota);
+		zfs_close(zfsp);
+		return (-1);
+	}
+
+	zfs_close(zfsp);
+	DBG_INFO("smb_zfs_set_quota: Set (%s = %s)\n", q_req, quota);
+	return 0;
+}
+
+uint64_t
+smb_zfs_disk_free(struct smblibzfshandle *smblibzfsp,
+		  char *path, uint64_t *bsize, uint64_t *dfree,
+		  uint64_t *dsize, uid_t euid)
+{
+	size_t blocksize = 1024;
+	zfs_handle_t *zfsp = NULL;
+	char uu_req[256] = { 0 };
+	char uq_req[256] = { 0 };
+	uint64_t available, usedbysnapshots, usedbydataset,
+		usedbychildren, usedbyrefreservation, real_used, total,
+		userquota, userused, userquotarem;
+
+	snprintf(uu_req, sizeof(uu_req), "userused@%u", euid);
+	snprintf(uq_req, sizeof(uq_req), "userquota@%u", euid);
+	if (smblibzfsp->sli == NULL) {
+		DBG_ERR("Failed to retrieve smblibzfs_int handle\n");
+		return -1;
+	}
+
+	if (path == NULL) {
+		DBG_ERR("received NULL path\n");
+		return (-1);
+	}
+
+	zfsp = zfs_path_to_zhandle(smblibzfsp->sli->libzfsp, path,
+		ZFS_TYPE_VOLUME|ZFS_TYPE_DATASET|ZFS_TYPE_FILESYSTEM);
+	if (zfsp == NULL) {
+		DBG_ERR("Failed to convert path (%s) to zhandle\n", path);
+		return (-1);
+	}
+
+	available = zfs_prop_get_int(zfsp, ZFS_PROP_AVAILABLE);
+	usedbysnapshots = zfs_prop_get_int(zfsp, ZFS_PROP_USEDSNAP);
+	usedbydataset = zfs_prop_get_int(zfsp, ZFS_PROP_USEDDS);
+	usedbychildren = zfs_prop_get_int(zfsp, ZFS_PROP_USEDCHILD);
+	usedbyrefreservation = zfs_prop_get_int(zfsp, ZFS_PROP_USEDREFRESERV);
+	zfs_prop_get_userquota_int(zfsp, uq_req, &userquota);
+	zfs_prop_get_userquota_int(zfsp, uu_req, &userused);
+
+	zfs_close(zfsp);
+
+	real_used = usedbysnapshots + usedbydataset + usedbychildren;
+
+	userquotarem = (userquota - userused) / blocksize;
+	userquota /= blocksize;
+
+	total = (real_used + available) / blocksize;
+	available /= blocksize;
+
+	*bsize = blocksize;
+	if ( userquota && (available > userquotarem) ) {
+		*dfree = userquotarem;
+	}
+	else {
+		*dfree = available;
+	}
+	if ( userquota && (total > userquota) ) {
+		*dsize = userquota;
+	}
+	else {
+		*dsize = total;
+	}
+
+	return (*dfree);
+}
+
+int
+smb_zfs_create_child_dataset(struct smblibzfshandle *smblibzfsp,
+			     char *parent, const char *base,
+			     const char *quota)
+{
+	zfs_handle_t *zfsp;
+	zfs_handle_t *new_zfsp;
+	const char *parent_dataset;
+	char nd[PATH_MAX] = { 0 };
+
+	if (smblibzfsp->sli == NULL) {
+		DBG_ERR("Failed to retrieve smblibzfs_int handle\n");
+		return -1;
+	}
+	if (parent == NULL) {
+		return (-1);
+	}
+
+	zfsp = zfs_path_to_zhandle(smblibzfsp->sli->libzfsp, parent,
+		ZFS_TYPE_VOLUME|ZFS_TYPE_DATASET|ZFS_TYPE_FILESYSTEM);
+
+	if (zfsp == NULL) {
+		DBG_ERR("Failed to obtain zhandle on parent directory: (%s)\n", parent);
+		return (-1);
+	}
+	parent_dataset = zfs_get_name(zfsp);
+	snprintf(nd, sizeof(nd), "%s/%s", parent_dataset, base);
+
+	if (zfs_create(smblibzfsp->sli->libzfsp, nd, ZFS_TYPE_DATASET, NULL) != 0){
+		DBG_ERR("Failed to create dataset to path (%s)\n", nd);
+		zfs_close(zfsp);
+		return (-1);
+	}
+	zfs_close(zfsp);
+
+	new_zfsp = zfs_open(smblibzfsp->sli->libzfsp, nd, ZFS_TYPE_DATASET);
+
+	if (new_zfsp == NULL) {
+		DBG_ERR("Failed to obtain zhandle on new dataset: (%s)\n", nd);
+		return (-1);
+	}
+
+	if (zfs_mount(new_zfsp, NULL, 0) != 0) {
+		DBG_ERR("Failed to mount ZFS dataset (%s)\n", nd);
+	}
+
+	if (zfs_prop_inherit(new_zfsp, zfs_prop_to_name(ZFS_PROP_ACLMODE), B_FALSE) < 0){
+		DBG_ERR("Failed to inherit aclmode from parent dataset\n");
+	}
+	if (quota) {
+		if (zfs_prop_set(new_zfsp, "quota", quota) != 0) {
+			DBG_ERR("Failed to set quota to (%s)\n", quota);
+		}
+	}
+
+	DBG_INFO("Created ZFS dataset (%s) with quota (%s)\n", nd, quota);
+
+	zfs_close(new_zfsp);
+	return 0;
+}
+
+int
+smb_zfs_get_user_prop(struct smblibzfshandle *smblibzfsp,
+		      TALLOC_CTX *mem_ctx,
+		      const char *path,
+		      const char *prop,
+		      char **value)
+{
+	int ret;
+	zfs_handle_t *zfsp = NULL;
+	nvlist_t *userprops = NULL;
+	nvlist_t *propval = NULL;
+	char *propstr = NULL;
+	char *prefixed_prop = NULL;
+
+	zfsp = get_zhandle(smblibzfsp, path);
+	if (zfsp == NULL) {
+		DBG_ERR("Failed to obtain zhandle on path: (%s)\n", path);
+		return -1;
+	}
+	userprops = zfs_get_user_props(zfsp);
+	prefixed_prop = talloc_asprintf(mem_ctx, "%s:%s",
+					ZFS_PROP_SAMBA_PREFIX,
+					prop);
+	ret = nvlist_lookup_nvlist(userprops, prefixed_prop, &propval);
+	if (ret != 0) {
+		DBG_INFO("Failed to look up custom user property %s "
+			 "on path [%s]: %s\n", prop, path, strerror(errno));
+		zfs_close(zfsp);
+		return -1;
+	}
+	ret = nvlist_lookup_string(propval, ZPROP_VALUE, &propstr);
+	TALLOC_FREE(prefixed_prop);
+	if (ret != 0) {
+		DBG_ERR("Failed to get nvlist string for property %s\n",
+			prop);
+		zfs_close(zfsp);
+		return -1;
+	}
+	*value = talloc_strdup(mem_ctx, propstr);
+	zfs_close(zfsp);
+	return 0;
+}
+
+int
+smb_zfs_set_user_prop(struct smblibzfshandle *smblibzfsp,
+		      const char *path,
+		      const char *prop,
+		      const char *value)
+{
+	int ret;
+	zfs_handle_t *zfsp = NULL;
+	char prefixed_prop[ZFS_MAXPROPLEN] = {0};
+
+	zfsp = get_zhandle(smblibzfsp, path);
+
+	if (zfsp == NULL) {
+		DBG_ERR("Failed to obtain zhandle on path: (%s)\n", path);
+		return -1;
+	}
+
+	ret = snprintf(prefixed_prop, sizeof(prefixed_prop), "%s:%s",
+		       ZFS_PROP_SAMBA_PREFIX, prop);
+	if (ret < 0) {
+		DBG_ERR("Failed to generate property name: %s",
+			strerror(errno));
+		zfs_close(zfsp);
+		return -1;
+	}
+
+	ret = zfs_prop_set(zfsp, prefixed_prop, value);
+	if (ret != 0) {
+		DBG_ERR("Failed to set property [%s] on path [%s] to [%s]\n",
+			prefixed_prop, path, value);
+	}
+
+	zfs_close(zfsp);
+	return ret;
+}
+
+static int
+zhandle_get_props(struct smbzhandle *zfsp_ext,
+		  TALLOC_CTX *mem_ctx,
+		  struct zfs_dataset_prop **pprop)
+{
+	int casesens = 0;
+	int ret;
+	char buf[ZFS_MAXPROPLEN];
+	char source[ZFS_MAX_DATASET_NAME_LEN];
+	zprop_source_t sourcetype;
+	zfs_handle_t *zfsp = NULL;
+	struct zfs_dataset_prop *props = NULL;
+	props = *pprop;
+
+	zfsp = get_zhandle_from_smbzhandle(zfsp_ext);
+	if (zfsp == NULL) {
+		return -1;
+	}
+	if (zfs_prop_get(zfsp, ZFS_PROP_CASE,
+	    buf, sizeof(buf), &sourcetype,
+	    source, sizeof(source), B_FALSE) != 0) {
+		DBG_ERR("Failed to look up casesensitivity property\n");
+		return -1;
+	}
+	props->casesens = get_enum(buf, casesensitivity);
+	props->readonly = zfs_prop_get_int(zfsp, ZFS_PROP_READONLY);
+#if 0 /* properties we may wish to return in the future */
+	props->exec = zfs_prop_get_int(zfsp, ZFS_PROP_EXEC);
+	props->atime = zfs_prop_get_int(zfsp, ZFS_PROP_ATIME);
+	props->setuid = zfs_prop_get_int(zfsp, ZFS_PROP_SETUID);
+#endif
+	return 0;
+}
+
+struct zfs_dataset *zhandle_get_dataset(struct smbzhandle *zfsp_ext,
+					TALLOC_CTX *mem_ctx,
+					bool get_props)
+{
+	int ret;
+	zfs_handle_t *zfsp = NULL;
+	struct zfs_dataset *dsout = NULL;
+	struct stat ds_st;
+	zfsp = get_zhandle_from_smbzhandle(zfsp_ext);
+	if (zfsp == NULL) {
+		return NULL;
+	}
+	dsout = talloc_zero(mem_ctx, struct zfs_dataset);
+	if (dsout == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+	dsout->mountpoint = talloc_zero_size(dsout, PATH_MAX);
+	if (dsout->mountpoint == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+	dsout->zhandle = zfsp_ext;
+	dsout->dataset_name = talloc_strdup(dsout, zfs_get_name(zfsp));
+	ret = zfs_prop_get(zfsp, ZFS_PROP_MOUNTPOINT, dsout->mountpoint,
+			   talloc_get_size(dsout->mountpoint), NULL, NULL,
+			   0, 0);
+	if (ret != 0) {
+		DBG_ERR("Failed to get mountpoint for %s: %s\n",
+			dsout->dataset_name, strerror(errno));
+		TALLOC_FREE(dsout);
+		dsout = NULL;
+	}
+	if (get_props) {
+		dsout->properties = talloc_zero(dsout, struct zfs_dataset_prop);
+		if (dsout->properties == NULL) {
+			errno = ENOMEM;
+			return NULL;
+		}
+		ret = zhandle_get_props(zfsp_ext, mem_ctx, &dsout->properties);
+		if (ret != 0) {
+			DBG_ERR("Failed to get properties for dataset\n");
+			dsout = NULL;
+		}
+	}
+	ret = stat(dsout->mountpoint, &ds_st);
+	if (ret < 0) {
+		DBG_ERR("Failed to stat dataset mounpoint [%s] "
+			"for dataset [%s]: %s\n",
+			dsout->mountpoint, dsout->dataset_name,
+			strerror(errno));
+		return NULL;
+	}
+	dsout->devid = ds_st.st_dev;
+	return dsout;
+}
+
+struct zfs_dataset *smb_zfs_path_get_dataset(struct smblibzfshandle *smblibzfsp,
+					     TALLOC_CTX *mem_ctx,
+					     const char *path,
+					     bool get_props,
+					     bool open_zhandle)
+{
+	int ret;
+	struct zfs_dataset *dsout = NULL;
+	struct smbzhandle *zfs_ext = NULL;
+	ret = get_smbzhandle(smblibzfsp, mem_ctx, path, &zfs_ext);
+	if (ret != 0) {
+		DBG_ERR("Failed to get zhandle\n");
+		return NULL;
+	}
+	dsout = zhandle_get_dataset(zfs_ext, mem_ctx, get_props);
+	if (dsout == NULL) {
+		return dsout;
+	}
+	if (!open_zhandle) {
+		close_smbzhandle(dsout->zhandle);
+	}
+	return dsout;
+}
+
+int
+smb_zfs_get_case_sensitivity(struct smblibzfshandle *smblibzfsp, char* path)
+{
+	int casesens = 0;
+	char buf[ZFS_MAXPROPLEN];
+	char source[ZFS_MAX_DATASET_NAME_LEN];
+	zprop_source_t sourcetype;
+	zfs_handle_t *zfsp = NULL;
+
+	zfsp = get_zhandle(smblibzfsp, path);
+	if (zfsp == NULL) {
+		DBG_ERR("Failed to obtain zhandle on path: (%s)\n", path);
+		return (-1);
+	}
+	if (zfs_prop_get(zfsp, ZFS_PROP_CASE,
+	    buf, sizeof(buf), &sourcetype,
+	    source, sizeof(source), B_FALSE) != 0) {
+		DBG_ERR("Failed to look up casesensitivity propertiy on path: (%s)\n",
+			path);
+		zfs_close(zfsp);
+		return (-1);
+	}
+	casesens = get_enum(buf, casesensitivity);
+	zfs_close(zfsp);
+	return casesens;
+}
+
+static bool
+shadow_copy_zfs_is_snapshot_included(struct iter_info *info,
+    const char *snap_name)
+{
+	const char **pattern;
+
+	pattern = info->inclusions;
+	while (*pattern) {
+		if (unix_wild_match(*pattern, snap_name)) {
+			break;
+		}
+		pattern++;
+	}
+
+	if (*info->inclusions && !*pattern) {
+		DBG_INFO("smb_zfs_add_snapshot: snapshot %s "
+			    "not in inclusion list\n", snap_name);
+		return false;
+	}
+
+	pattern = info->exclusions;
+	while (*pattern) {
+		if (unix_wild_match(*pattern, snap_name)) {
+			DBG_INFO("smb_zfs_add_snapshot: snapshot %s "
+				    "in exclusion list\n", snap_name);
+			return false;
+		}
+		pattern++;
+	}
+
+	return true;
+}
+
+static int
+smb_zfs_add_snapshot(zfs_handle_t *snap, void *data)
+{
+	struct snap_cb *state = NULL;
+	struct snapshot_entry *entry = NULL;
+	const char *snap_name;
+	time_t cr_time;
+	struct tm timestamp;
+	int rc, used;
+	size_t req_mem, name_len;
+
+	state = talloc_get_type_abort(data, struct snap_cb);
+	if (state == NULL) {
+		DBG_ERR("failed to get snap_cb private data\n");
+		zfs_close(snap);
+		errno = ENOMEM;
+		return -1;
+	}
+
+	/* ignore excluded snapshots */
+	snap_name = strchr(zfs_get_name(snap), '@') + 1;
+
+	if (!shadow_copy_zfs_is_snapshot_included(state->iter_info, snap_name)) {
+		zfs_close(snap);
+		return 0;
+	}
+
+	used = zfs_prop_get_int(snap, ZFS_PROP_USED);
+	if (used == 0 && state->snapshots->num_entries != 0) {
+		if (!((state->prev_u == 0) &&
+		      (state->prev_prev_u != 0))) {
+			state->prev_prev_u = state->prev_u;
+			state->prev_u = used;
+			goto done;
+		}
+		state->prev_prev_u = state->prev_u;
+		state->prev_u = used;
+	}
+
+	cr_time = zfs_prop_get_int(snap, ZFS_PROP_CREATION);
+
+	if (state->iter_info->start && state->iter_info->start > cr_time) {
+		zfs_close(snap);
+		return 0;
+	}
+	if (state->iter_info->end && state->iter_info->end < cr_time) {
+		zfs_close(snap);
+		return 0;
+	}
+
+	entry = talloc_zero(state->snapshots, struct snapshot_entry);
+	if (entry == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+
+	name_len = strlen(snap_name);
+	gmtime_r(&cr_time, &timestamp);
+	strftime(entry->label, sizeof(entry->label), SHADOW_COPY_ZFS_GMT_FORMAT,
+		 &timestamp);
+
+	entry->cr_time = cr_time;
+	unix_to_nt_time(&entry->nt_time, cr_time);
+	entry->name = talloc_strndup(entry, snap_name, name_len +1);
+
+	DLIST_ADD(state->snapshots->entries, entry);
+	state->snapshots->num_entries++;
+done:
+	zfs_close(snap);
+	return 0;
+}
+
+int zhandle_jail(struct smbzhandle *zhandle_ext,
+		 int jid, int attach)
+{
+	if (!zhandle_ext->is_open) {
+		DBG_ERR("zhandle is not open!\n");
+		return -1;
+	}
+	int ret;
+	zfs_handle_t *zfs = NULL;
+	zfs = get_zhandle_from_smbzhandle(zhandle_ext);
+	if (!zfs) {
+		return -1;
+	}
+	ret = (zfs_jail(zfs, jid, attach) != 0);
+	return ret;
+}
+
+struct
+snapshot_list *zhandle_list_snapshots(struct smbzhandle *zhandle_ext,
+				      TALLOC_CTX *mem_ctx,
+				      bool ignore_empty_snaps,
+				      const char **inclusions,
+				      const char **exclusions,
+				      time_t start,
+				      time_t end)
+{
+	TALLOC_CTX *tmp_ctx = NULL;
+	struct snap_cb *state = NULL;
+	struct snapshot_list *snapshots = NULL;
+	struct iter_info iter_info;
+	size_t initial_size;
+	int rc;
+	zfs_handle_t *zfs = NULL;
+
+	zfs = get_zhandle_from_smbzhandle(zhandle_ext);
+	if (!zfs) {
+		return NULL;
+	}
+
+	tmp_ctx = talloc_new(mem_ctx);
+	if (tmp_ctx == NULL) {
+		DBG_ERR("talloc() failed\n");
+		return NULL;
+	}
+
+	state = talloc_zero(tmp_ctx, struct snap_cb);
+	if (state == NULL) {
+		DBG_ERR("smb_zfs_list_snapshots: out of memory");
+		goto done;
+	}
+
+	snapshots = talloc_zero(mem_ctx, struct snapshot_list);
+	if (snapshots == NULL) {
+		DBG_ERR("talloc() failed\n");
+		goto done;
+	}
+
+	snapshots->mountpoint = talloc_zero_size(snapshots, MAXPATHLEN);
+	if (snapshots->mountpoint == NULL) {
+		DBG_ERR("talloc() failed\n");
+		goto error;
+	}
+
+	state->iter_info = talloc_zero(tmp_ctx, struct iter_info);
+	if (state->iter_info == NULL) {
+		DBG_ERR("talloc() failed\n");
+		goto error;
+	}
+
+	state->snapshots = snapshots;
+
+	/* get mountpoint */
+	snapshots->dataset_name = talloc_strdup(snapshots, zfs_get_name(zfs));
+
+	rc = zfs_prop_get(zfs, ZFS_PROP_MOUNTPOINT, snapshots->mountpoint,
+			  talloc_get_size(snapshots->mountpoint), NULL, NULL,
+			  0, 0);
+
+	if (rc != 0) {
+		DBG_ERR("smb_zfs_list_snapshots: error getting "
+			"mountpoint for '%s': %s\n", snapshots->dataset_name, strerror(errno));
+		goto error;
+	}
+
+	state->iter_info->inclusions = inclusions;
+	state->iter_info->exclusions = exclusions;
+	state->iter_info->ignore_empty_snaps = ignore_empty_snaps;
+	state->iter_info->start = start;
+	state->iter_info->end = end;
+
+	if (state->iter_info->inclusions == NULL) {
+		DBG_ERR("smb_zfs_list_snapshots: error getting "
+			"shadow:include parameter\n");
+		goto error;
+	}
+
+	if (state->iter_info->exclusions == NULL) {
+		DBG_ERR("smb_zfs_list_snapshots: error getting "
+			"shadow:exclude parameter\n");
+		goto error;
+	}
+	rc = zfs_iter_snapshots_sorted(zfs, smb_zfs_add_snapshot, state, 0, 0);
+
+	if (rc != 0) {
+		DBG_ERR("smb_zfs_list_snapshots: error getting "
+			"snapshots for '%s': %s\n",
+			snapshots->dataset_name, strerror(errno));
+		goto error;
+	}
+
+	time(&snapshots->timestamp);
+	state->snapshots = NULL;
+	goto done;
+
+error:
+	TALLOC_FREE(tmp_ctx);
+	TALLOC_FREE(snapshots);
+	return NULL;
+done:
+	TALLOC_FREE(tmp_ctx);
+	return snapshots;
+}
+
+struct
+snapshot_list *smb_zfs_list_snapshots(struct smblibzfshandle *smblibzfsp,
+				      TALLOC_CTX *mem_ctx,
+				      const char *path,
+				      bool ignore_empty_snaps,
+				      const char **inclusions,
+				      const char **exclusions,
+				      time_t start,
+				      time_t end)
+{
+	int ret;
+	struct smbzhandle *zfs_ext = NULL;
+	struct snapshot_list *out = NULL;
+	ret = get_smbzhandle(smblibzfsp, mem_ctx, path, &zfs_ext);
+	if (ret != 0) {
+		DBG_ERR("Failed to get zhandle\n");
+		return NULL;
+	}
+	out = zhandle_list_snapshots(zfs_ext, mem_ctx,
+				     ignore_empty_snaps,
+				     inclusions,
+				     exclusions,
+				     start,
+				     end);
+	close_smbzhandle(zfs_ext);
+	return out;
+}
+
+/*
+ * Convert linked list to nvlist and perform delete in single
+ * consolidated ioctl.
+ */
+int
+smb_zfs_delete_snapshots(struct smblibzfshandle *smblibzfsp,
+			 TALLOC_CTX *mem_ctx,
+			 struct snapshot_list *snaps)
+{
+	int ret;
+	nvlist_t *to_delete = NULL;
+	struct smblibzfs_int *slibzp_int = NULL;
+	struct snapshot_entry *entry = NULL;
+	char *snapname = NULL;
+	if (smblibzfsp->sli == NULL) {
+		errno=ENOMEM;
+		DBG_ERR("Unable to re-use libzfs handle\n");
+		return -1;
+	}
+	ret = nvlist_alloc(&to_delete, NV_UNIQUE_NAME, 0);
+	if (ret != 0) {
+		DBG_ERR("Failed to initialize nvlist for snaps.\n");
+		errno=ENOMEM;
+		return -1;
+	}
+	for (entry = snaps->entries; entry; entry = entry->next) {
+		snapname = talloc_asprintf(mem_ctx,
+					   "%s@%s",
+					   snaps->dataset_name,
+					   entry->name);
+		DBG_INFO("deleting snapshot: %s\n", snapname);
+		fnvlist_add_boolean(to_delete, snapname);
+		TALLOC_FREE(snapname);
+	}
+	ret = zfs_destroy_snaps_nvl(smblibzfsp->sli->libzfsp,
+				    to_delete,
+				    B_TRUE);
+	if (ret !=0) {
+		DBG_ERR("Failed to delete snapshots\n");
+		return ret;
+	}
+	return 0;
+}
+
+/*
+ * Create snapshot with specified name on specified dataset.
+ */
+int
+smb_zfs_snapshot(struct smblibzfshandle *smblibzfsp,
+		 const char *path,
+		 const char *snapshot_name,
+		 bool recursive)
+{
+	int ret;
+	zfs_handle_t *zfsp = NULL;
+	char snap[ZFS_MAXPROPLEN] = {0};
+	const char *dataset_name;
+
+	if (smblibzfsp->sli == NULL) {
+		errno=ENOMEM;
+		return -1;
+	}
+
+	zfsp = get_zhandle(smblibzfsp, path);
+	if (zfsp == NULL) {
+		DBG_ERR("Failed to obtain zhandle on path: (%s)\n",
+			path);
+		return -1;
+	}
+	dataset_name = zfs_get_name(zfsp);
+	zfs_close(zfsp);
+	ret = snprintf(snap, sizeof(snap), "%s@%s",
+		       dataset_name, snapshot_name);
+	if (ret < 0) {
+		DBG_ERR("Failed to format snapshot name:%s\n",
+			strerror(errno));
+		return -1;
+	}
+	ret = zfs_snapshot(smblibzfsp->sli->libzfsp,
+			   snap, recursive, NULL);
+	if (ret != 0) {
+		DBG_ERR("Failed to create snapshot %s: [%s]\n",
+			snap, strerror(errno));
+	}
+	DBG_INFO("Successfully created snapshot: %s\n", snap);
+	return ret;
+}
+
+/*
+ * Roll back to specified snapshot
+ */
+int
+smb_zfs_rollback(struct smblibzfshandle *smblibzfsp,
+		 const char *path,
+		 const char *snapshot_name,
+		 bool force)
+{
+	int ret;
+	zfs_handle_t *dataset_handle = NULL;
+	zfs_handle_t *snap_handle = NULL;
+
+	if (smblibzfsp->sli == NULL) {
+		errno=ENOMEM;
+		return -1;
+	}
+
+	dataset_handle = get_zhandle(smblibzfsp, path);
+	if (dataset_handle == NULL) {
+		DBG_ERR("Failed to obtain zhandle on path: (%s)\n",
+			path);
+		return -1;
+	}
+
+	snap_handle = zfs_open(smblibzfsp->sli->libzfsp, snapshot_name,
+			       ZFS_TYPE_DATASET);
+	if (snap_handle == NULL) {
+		DBG_ERR("Failed to obtain zhandle for snap: (%s)\n",
+			snapshot_name);
+		zfs_close(dataset_handle);
+		return -1;
+	}
+	ret = zfs_rollback(dataset_handle, snap_handle, force);
+	if (ret != 0) {
+		DBG_ERR("Failed to roll back %s to snapshot %s\n",
+			path, snapshot_name);
+	}
+	zfs_close(dataset_handle);
+	zfs_close(snap_handle);
+	return ret;
+}
+
+/*
+ * Roll back to last snapshot
+ */
+int
+smb_zfs_rollback_last(struct smblibzfshandle *smblibzfsp,
+		      const char *path)
+{
+	int ret;
+	zfs_handle_t *dataset_handle = NULL;
+	const char *dataset_name;
+
+	dataset_handle = get_zhandle(smblibzfsp, path);
+	if (dataset_handle == NULL) {
+		DBG_ERR("Failed to obtain zhandle on path: (%s)\n",
+			path);
+		return -1;
+	}
+	dataset_name = zfs_get_name(dataset_handle);
+
+	ret = lzc_rollback(dataset_name, NULL, 0);
+	if (ret != 0) {
+		DBG_ERR("Failed to roll back snapshot on %s\n", path);
+	}
+	zfs_close(dataset_handle);
+	return ret;
+}
+
+static int
+smb_zfs_add_child(zfs_handle_t *child, void *data)
+{
+	struct child_cb *state = NULL;
+	struct smbzhandle *zhandle_ext = NULL;
+	struct smbzhandle_int *zhandle_int = NULL;
+	struct zfs_dataset *ds_new = NULL;
+	if (zfs_get_type(child) != ZFS_TYPE_FILESYSTEM) {
+		return 0;
+	}
+	if (!zfs_is_mounted(child, NULL)) {
+		DBG_INFO("Dataset [%s] is not mounted\n",
+			 zfs_get_name(child));
+		return 0;
+	}
+	state = talloc_get_type_abort(data, struct child_cb);
+	if (state == NULL) {
+		DBG_ERR("failed to get child_cb private data\n");
+		zfs_close(child);
+		errno = ENOMEM;
+		return -1;
+	}
+	zhandle_ext = talloc_zero(state->dslist, struct smbzhandle);
+	if (zhandle_ext == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+	zhandle_int = talloc_zero(zhandle_ext, struct smbzhandle_int);
+	if (zhandle_int == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+	zhandle_ext->zhp = zhandle_int;
+	zhandle_ext->is_open = true;
+	zhandle_int->zhandle = child;
+	ds_new = zhandle_get_dataset(zhandle_ext, state->dslist, true);
+	if (ds_new == NULL) {
+		close_smbzhandle(zhandle_ext);
+		TALLOC_FREE(zhandle_ext);
+		return 0;
+	}
+	if (!state->open_zhandle) {
+		close_smbzhandle(ds_new->zhandle);
+	}
+	DLIST_ADD(state->dslist->children, ds_new);
+	state->dslist->nentries++;
+	return 0;
+}
+
+static struct dataset_list *cache_get_dataset_list(TALLOC_CTX *mem_ctx, struct smbzhandle *zh)
+{
+	char *ds_name = NULL;
+	struct dataset_list *out = NULL;
+	int ret;
+	ret = smb_get_dataset_name(zh, &ds_name);
+	if (ret != 0) {
+		DBG_ERR("Failed to get dataset name\n");
+		return NULL;
+	}
+	char *keystr = talloc_asprintf(mem_ctx, "dataset_list:%s", ds_name);
+	out = (struct dataset_list *)memcache_lookup_talloc(
+					zh->lz->zcache,
+					ZFS_CACHE,
+					data_blob_const(discard_const_p(uint8_t, ds_name), strlen(ds_name)));
+	TALLOC_FREE(keystr);
+	return out;
+}
+
+static void *cache_set_dataset_list(TALLOC_CTX *mem_ctx, struct dataset_list *dsl)
+{
+	char *keystr = talloc_asprintf(mem_ctx, "dataset_list:%s",
+				    dsl->root->dataset_name);
+	DATA_BLOB key = data_blob_const(discard_const_p(uint8_t, keystr),
+					strlen(keystr));
+
+	memcache_add_talloc(dsl->root->zhandle->lz->zcache,
+			    ZFS_CACHE, key, &dsl);
+	TALLOC_FREE(keystr);
+}
+
+struct dataset_list *zhandle_list_children(TALLOC_CTX *mem_ctx,
+					  struct smbzhandle *zhandle_ext,
+					  bool open_zhandles)
+{
+	int ret ;
+	TALLOC_CTX *tmp_ctx = NULL;
+	struct dataset_list *dl = NULL;
+	char *ds_name = NULL;
+	struct child_cb *state = NULL;
+	zfs_handle_t *zfsp = NULL;
+
+	zfsp = get_zhandle_from_smbzhandle(zhandle_ext);
+	if (zfsp == NULL) {
+		return NULL;
+	}
+
+	tmp_ctx = talloc_new(mem_ctx);
+	if (tmp_ctx == NULL) {
+		DBG_ERR("talloc() failed\n");
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	state = talloc_zero(tmp_ctx, struct child_cb);
+	if (state == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+	state->open_zhandle = open_zhandles;
+	dl = talloc_zero(mem_ctx, struct dataset_list);
+	if (dl == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+	state->dslist = dl;
+	dl->root = zhandle_get_dataset(zhandle_ext, mem_ctx, true);
+	if (dl->root == NULL) {
+		DBG_ERR("Failed to get dataset information for root "
+			"of dataset list\n");
+		TALLOC_FREE(tmp_ctx);
+		TALLOC_FREE(dl);
+		return NULL;
+	}
+	ret = zfs_iter_filesystems(zfsp, smb_zfs_add_child, state);
+	TALLOC_FREE(tmp_ctx);
+	if (ret < 0) {
+		TALLOC_FREE(dl);
+		return NULL;
+	}
+	return dl;
+}
+
+struct dataset_list *cache_zhandle_list_children(TALLOC_CTX *mem_ctx,
+					  struct smbzhandle *zhandle_ext)
+{
+	struct dataset_list *dl;
+	dl = cache_get_dataset_list(mem_ctx, zhandle_ext);
+	if (dl != NULL) {
+		return dl;
+	}
+	dl = zhandle_list_children(mem_ctx, zhandle_ext, false);
+	if (dl == NULL) {
+		return dl;
+	}
+	cache_set_dataset_list(mem_ctx, dl);
+	return dl;
+}
+
+int jail_dataset_list(struct dataset_list *ds_list, int jid)
+{
+	int ret = 0;
+	struct zfs_dataset *child = NULL;
+	struct stat ds_st;
+	if (!ds_list->root->zhandle->is_open) {
+		DBG_ERR("zhandle for %s is closed\n",
+			ds_list->root->dataset_name);
+		errno = ENOMEM;
+		return -1;
+	}
+	if (jid != -1) {
+		ret = zhandle_jail(ds_list->root->zhandle, jid, true);
+		if (ret != 0) {
+			DBG_ERR("zhandle_jail failed with %s\n", strerror(errno));
+			errno = ENOMEM;
+		}
+	}
+	ret = stat(ds_list->root->mountpoint, &ds_st);
+	if (ret < 0) {
+		DBG_ERR("Failed to stat dataset mounpoint [%s] "
+			"for dataset [%s]: %s\n",
+			ds_list->root->mountpoint,
+			ds_list->root->dataset_name,
+			strerror(errno));
+			return -1;
+	}
+	ds_list->root->devid = ds_st.st_dev;
+	for (child=ds_list->children; child; child=child->next) {
+		if (!child->zhandle->is_open) {
+			DBG_ERR("zhandle for %s is closed\n",
+				child->dataset_name);
+			errno = ENOMEM;
+			return -1;
+		}
+		if (jid != -1) {
+			ret = zhandle_jail(child->zhandle, jid, true);
+			if (ret != 0) {
+				DBG_ERR("zfs_jail failed for %s: %s\n",
+					child->dataset_name, jid);
+			}
+		}
+		ret = stat(child->mountpoint, &ds_st);
+		if (ret < 0) {
+			DBG_ERR("Failed to stat dataset mounpoint [%s] "
+				"for dataset [%s]: %s\n",
+				child->mountpoint, child->dataset_name,
+				strerror(errno));
+			return -1;
+		}
+		child->devid = ds_st.st_dev;
+		close_smbzhandle(child->zhandle);
+	}
+	close_smbzhandle(ds_list->root->zhandle);
+	return 0;
+}
diff --git a/source3/modules/smb_libzfs.h b/source3/modules/smb_libzfs.h
new file mode 100644
index 00000000000..2e551e2dd97
--- /dev/null
+++ b/source3/modules/smb_libzfs.h
@@ -0,0 +1,403 @@
+/*-
+ * Copyright 2018 iXsystems, Inc.
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef	__SMB_LIBZFS_H
+#define	__SMB_LIBZFS_H
+#include <pwd.h>
+#include <talloc.h>
+
+struct smblibzfs_int;
+struct smbzhandle_int;
+
+struct smblibzfshandle {
+	struct memcache *zcache;
+	struct db_context *db;
+	struct smblibzfs_int *sli;
+};
+
+struct smbzhandle {
+	struct smblibzfshandle *lz;
+	struct smbzhandle_int *zhp;
+	bool is_open;
+};
+
+struct snapshot_entry
+{
+	char label[25];		/* @GMT-prefixed label for snapshot */
+	char *name;		/* name of snapshot */
+	time_t cr_time;		/* creation time of snapshot */
+	NTTIME nt_time;		/* creation time as nt_time */
+	struct snapshot_entry *prev, *next;
+};
+
+struct snapshot_list
+{
+	time_t timestamp;	/* when list generated */
+	char *mountpoint;	/* mountpoint of ZFS dataset where list taken */
+	char *dataset_name;	/* ZFS dataset name that the list is for */
+	size_t num_entries;	/* number of entries in snapshot list */
+	struct snapshot_entry *entries;
+};
+
+enum casesensitivity {SMBZFS_SENSITIVE, SMBZFS_INSENSITIVE, SMBZFS_MIXED};
+
+struct zfs_dataset_prop
+{
+	enum casesensitivity casesens;
+	int readonly;
+#if 0 /* Properties we may wish to expose in the future */
+	int atime;
+	int exec;
+	int setuid;
+#endif
+};
+
+struct zfs_dataset
+{
+	char *dataset_name;
+	char *mountpoint;
+	struct smbzhandle *zhandle;
+	dev_t devid;
+	struct zfs_dataset_prop *properties;
+	struct zfs_dataset *prev, *next;
+};
+
+struct dataset_list
+{
+	time_t timestamp;	/* when list generated */
+	struct zfs_dataset *root;
+	struct zfs_dataset *children;
+	size_t nentries;
+};
+
+/*
+ * Get an smblibzfshandle. This is to allow reuse of the same libzfs handle,
+ * which provides performance and efficiency benefits. The libzfs handle will
+ * be automatically closed in the destructor function for the smblibzfshandle.
+ *
+ * @param[in]	mem_ctx			talloc memory context
+ * @param[out]	smblibzfsp		smblibzfs handle struct
+ *
+ * @return	0 on success -1 on failure
+ */
+
+int get_smblibzfs_handle(TALLOC_CTX *mem_ctx,struct smblibzfshandle **smblibzfsp);
+
+int get_smbzhandle(struct smblibzfshandle *smblibzfsp,
+		   TALLOC_CTX *mem_ctx, char *path,
+		   struct smbzhandle **smbzhandle);
+
+int zhandle_jail(struct smbzhandle *zhandle_ext,
+		 int jid, int attach);
+
+/*
+ * Get dataset name for a given path. This is useful because there may be
+ * multiple ZFS datasets within a single SMB share.
+ *
+ * @param[in]	smblibzfsp		smblibzfs handle struct
+ * @param[in]	pathname	 	full path in which to get dataset name.
+ * @param[out]	dataset_name_out	name of ZFS dataset
+ *
+ * @return	0 on success -1 on failure
+ */
+int smb_zfs_path_to_dataset(struct smblibzfshandle *smblibzfsp,
+			    const char *pathname,
+			    const char **dataset_name_out);
+
+/*
+ * Get dataset name for a given path. This is useful because there may be
+ * multiple ZFS datasets within a single SMB share.
+ *
+ * @param[in]	smblibzfsp		smblibzfs handle struct
+ * @param[in]	mem_ctx			talloc memory context
+ * @param[in]	dataset_name		name of ZFS dataset.
+ * @param[out]	dataset_mp_out		mountpoint of ZFS dataset (talloc'ed string).
+ *
+ * @return	0 on success -1 on failure
+ */
+int smb_zfs_dataset_name_to_mp(struct smblibzfshandle *smblibzfsp,
+			       TALLOC_CTX *mem_ctx,
+			       const char *dataset_name,
+			       char **dataset_mp_out);
+/*
+ * Get userspace quotas for a given path, ID, and quota type.
+ * @param[in]	smblibzfsp		smblibzfs handle struct
+ * @param[in]	path		 	the full path in which to get quota.
+ * @param[in]	xid		 	user id or group id.
+ * @param[in]	quota_type	 	quota type
+ * @param[out]	hardlimit	 	quota size in bytes
+ * @param[out]	usedspace		space used against quota in bytes
+ *
+ * @return	0 on success -1 on failure
+ */
+int smb_zfs_get_userspace_quota(struct smblibzfshandle *smblibzfsp,
+				char *path,
+				int64_t xid,
+				int quota_type,
+				uint64_t *hardlimit,
+				uint64_t *usedspace);
+
+/*
+ * Set userspace quotas for a given path, ID, and quota type. May require
+ * fail with EPERM if user lacks permissions to set quota.
+ * @param[in]	smblibzfsp		smblibzfs handle struct
+ * @param[in]	path		 	the full path in which to get quota.
+ * @param[in]	xid		 	user id or group id.
+ * @param[in]	quota_type	 	quota type
+ * @param[in]	hardlimit	 	quota size in bytes
+ *
+ * @return	0 on success -1 on failure
+ */
+int smb_zfs_set_userspace_quota(struct smblibzfshandle *smblibzfsp,
+				char *path,
+				int64_t xid,
+				int quota_type,
+				uint64_t hardlimit);
+
+uint64_t smb_zfs_disk_free(struct smblibzfshandle *smblibzfsp,
+			   char *path,
+			   uint64_t *bsize,
+			   uint64_t *dfree,
+			   uint64_t *dsize,
+			   uid_t euid);
+
+/*
+ * This function creates a child dataset of a specified parent dataset.
+ * Realpath of parent dataset should be passed into the function. Name
+ * of child dataset is expected to be relative to parent dataset. For example,
+ * if parent datset is tank/share and you wish to create tank/share/sub1
+ * then the expected name of the child dataset is "sub1". Aclmode
+ * will be inherited from parent.
+ *
+ * @param[in]	smblibzfsp		smblibzfs handle struct
+ * @para[in]	parent			real path to parent dataset
+ * @param[in]	base			name of child dataset.
+ * @param[in]	quota			ZFS dataset quota
+ *
+ * @return	0 on success -1 on failure.
+ */
+int smb_zfs_create_child_dataset(struct smblibzfshandle *smblibzfsp,
+				 char *parent,
+				 const char *new,
+				 const char *quota);
+
+/*
+ * Retrieve the value of a user-defined ZFS dataset property
+ * "org.samba:" prefix will be automatically applied.
+ *
+ * @param[in]	smblibzfsp		smblibzfs handle struct
+ * @param[in]	mem_ctx			talloc memory context
+ * @param[in]	path			path on which to retrieve
+ *					custom user property
+ * @param[in]	prop			property name
+ * @param[out]	value			talloc'ed string containing
+ *					value of propert.
+ *
+ * @return	0 on success -1 on failure
+ */
+int smb_zfs_get_user_prop(struct smblibzfshandle *smblibzfsp,
+			  TALLOC_CTX *mem_ctx,
+			  const char *path,
+			  const char *prop,
+			  char **value);
+
+/*
+ * Set the value of a user-defined ZFS dataset property.
+ * "org.samba:" prefix will be automatically applied.
+ *
+ * @param[in]	smblibzfsp		smblibzfs handle struct
+ * @param[in]	path			path on which to set
+ *					custom user property
+ * @param[in]	prop			property name
+ * @param[out]	value			value to set
+ *
+ * @return	0 on success -1 on failure
+ */
+int smb_zfs_set_user_prop(struct smblibzfshandle *smblibzfsp,
+			  const char *path,
+			  const char *prop,
+			  const char *value);
+
+/*
+ * Returns ZFS dataset information for a given path or dataset name.
+ * If get_props is set to True, then ZFS dataset properties are included
+ * in the returned zfs_dataset struct.
+ */
+struct zfs_dataset *smb_zfs_path_get_dataset(struct smblibzfshandle *smblibzfsp,
+                                             TALLOC_CTX *mem_ctx,
+                                             const char *path,
+                                             bool get_props,
+					     bool open_zhandle);
+
+int smb_get_dataset_name(struct smbzhandle *zhandle_ext, const char **dataset_name_out);
+/*
+ * This function returns a list of ZFS snapshots matching the specified
+ * filters, allocated under a user-provided talloc memory context. Returns
+ * NULL on error. It is a wrapper around zhandle_list_snapshots.
+ *
+ * @param[in]	smblibzfsp		smblibzfs handle struct
+ * @param[in]	mem_ctx			talloc memory context
+ * @param[in]	ignore_empty_snaps	ignore snapshots with zero space used
+ * @param[in]	inclusions		list of filters to determine whether to
+ *					include a snapshot
+ * @param[in]	exclusions		list of filters to determine whether to
+ *					exclude a snapshot
+ * @param[in]	start			snapshots with create time greater than
+ *					this will be included
+ * @param[in]	end			snapshots with create time less than
+ *					this will be included
+ *
+ * @return	struct snapshot_list
+ */
+struct snapshot_list *smb_zfs_list_snapshots(struct smblibzfshandle *smblibzfsp,
+					     TALLOC_CTX *mem_ctx,
+					     const char *fs,
+					     bool ignore_empty_snaps,
+					     const char **inclusions,
+					     const char **exclusions,
+					     time_t start,
+					     time_t end);
+
+/*
+ * This function returns a list of ZFS snapshots matching the specified
+ * filters, allocated under a user-provided talloc memory context. Returns
+ * NULL on error.
+ *
+ * @param[in]	smbzhandle		smbzhandle struct (typically from dataset).
+ * @param[in]	mem_ctx			talloc memory context
+ * @param[in]	ignore_empty_snaps	ignore snapshots with zero space used
+ * @param[in]	inclusions		list of filters to determine whether to
+ *					include a snapshot
+ * @param[in]	exclusions		list of filters to determine whether to
+ *					exclude a snapshot
+ * @param[in]	start			snapshots with create time greater than
+ *					this will be included
+ * @param[in]	end			snapshots with create time less than
+ *					this will be included
+ *
+ * @return	struct snapshot_list
+ */
+struct snapshot_list *zhandle_list_snapshots(struct smbzhandle *zhandle_ext,
+                                      TALLOC_CTX *mem_ctx,
+                                      bool ignore_empty_snaps,
+                                      const char **inclusions,
+                                      const char **exclusions,
+                                      time_t start,
+                                      time_t end);
+
+/*
+ * Delete a list of ZFS snapshots. List is converted into an nvlist
+ * and deletion performed in single ZFS ioctl. Required parts of
+ * snapshot list are snaps->dataset_name, and entry->name for entries.
+ *
+ * @param[in]	smblibzfsp		smblibzfs handle struct
+ * @param[in]	mem_ctx			talloc memory context
+ * @param[in]	snaps			list of snapshots to delete
+ *
+ * @return	0 on success -1 on failure
+ */
+int smb_zfs_delete_snapshots(struct smblibzfshandle *smblibzfsp,
+			     TALLOC_CTX *mem_ctx,
+			     struct snapshot_list *snaps);
+
+/*
+ * Take a named snapshot of a given path.
+ * @param[in]	smblibzfsp		smblibzfs handle struct
+ * @param[in]	path			path on which to take snapshot
+ * @param[in]	snapshot_name		name to give snapshot
+ *
+ * @return	0 on success -1 on failure
+ */
+int smb_zfs_snapshot(struct smblibzfshandle *smblibzfsp,
+		     const char *path,
+		     const char *snapshot_name,
+		     bool recursive);
+
+/*
+ * Roll back to named snapshot. This is a destructive process.
+ * Given a path, convert path to dataset handle and rollback to a specific
+ * snapshot, discarding any data changes since then and making it the
+ * active dataset.
+ *
+ * Any snapshots and bookmarks more recent than the target are
+ * destroyed, along with their dependents (i.e. clones).
+ *
+ * @param[in]	smblibzfsp		smblibzfs handle struct
+ * @param[in]	path			path on which to take snapshot
+ * @param[in]	snapshot_name		name to give snapshot
+ * @param[in]	force			forcibly unmount cloned filesystems
+ *
+ * @return	0 on success -1 on failure
+ */
+int smb_zfs_rollback(struct smblibzfshandle *smblibzfsp,
+		     const char *path,
+		     const char *snapshot_name,
+		     bool force);
+
+/*
+ * Roll back to the last successful snapshot. This is a destructive process. All
+ * data from after the last snapshot was taken will be destroyed.
+ * @param[in]	smblibzfsp		smblibzfs handle struct
+ * @param[in]	path			path on which to take snapshot
+ * @param[in]	snapshot_name		name to give snapshot
+ *
+ * @return	0 on success -1 on failure
+ */
+int smb_zfs_rollback_last(struct smblibzfshandle *smblibzfsp, const char *path);
+
+void close_smbzhandle(struct smbzhandle *zfsp_ext);
+
+/*
+ * Get a list of child datasets of a given dataset using zfs_iter_filesystems.
+ *
+ * @param[in]	mem_ctx			talloc memory context on which to hang results.
+ * @param[in]	smbzhandle_ext		smb zfs dataset handle
+ * @param[in]	open_handles		specifies whether to leave zhandles on child
+ *					datasets open
+ * @param[out]	from_cache		true if returned from cache
+ * @return	dataset_list		dataset->root->zhandle is a pointer to the
+					same zhandle used to generate the dataset list.
+ */
+struct dataset_list *zhandle_list_children( TALLOC_CTX *mem_ctx,
+                                          struct smbzhandle *zhandle_ext,
+                                          bool open_zhandles);
+
+struct dataset_list *cache_zhandle_list_children(TALLOC_CTX *mem_ctx,
+						 struct smbzhandle *zhandle_ext);
+/*
+ * Attach a list of ZFS datasets to a specified jail. This function
+ * also will populate the devid field of the datasets. If jid is -1 then
+ * devid will be populated but dataset will not be jailed.
+ *
+ * @param[in]	ds_list			struct dataset_list to attach to jail.
+ * @param[in]	jid			jail id for jail.
+ *
+ * @return	0 on success -1 on failure.
+ */
+int jail_dataset_list(struct dataset_list *ds_list, int jid);
+
+#endif	/* !__SMB_LIBZFS_H */
diff --git a/source3/modules/vfs_ixnas.c b/source3/modules/vfs_ixnas.c
new file mode 100644
index 00000000000..199ba433dd5
--- /dev/null
+++ b/source3/modules/vfs_ixnas.c
@@ -0,0 +1,2018 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *  A dumping ground for FreeBSD-specific VFS functions. For testing case
+ *  of reducing number enabled VFS modules to bare minimum by creating
+ *  single large VFS module.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include "includes.h"
+#include "smbd/globals.h"
+#include "smbd/smbd.h"
+#include "libcli/security/security.h"
+#include "auth.h"
+#include "privileges.h"
+#include "nfs4_acls.h"
+#include "system/filesys.h"
+#include <fstab.h>
+#include <sys/types.h>
+#include <ufs/ufs/quota.h>
+#include <sys/acl.h>
+
+#if HAVE_LIBZFS
+#include "lib/util/tevent_ntstatus.h"
+#include "modules/smb_libzfs.h"
+#endif
+#include <libutil.h>
+
+static int vfs_ixnas_debug_level = DBGC_VFS;
+
+#undef DBGC_CLASS
+#define DBGC_CLASS vfs_ixnas_debug_level
+
+struct ixnas_config_data {
+	struct smbacl4_vfs_params nfs4_params;
+	struct smblibzfshandle *libzp;
+	bool dosattrib_xattr;
+	bool map_modify;
+	bool zfs_acl_ignore_empty_mode;
+	bool zfs_acl_chmod_enabled;
+	bool zfs_space_enabled;
+	bool zfs_quota_enabled;
+	bool zfs_auto_homedir;
+	struct zfs_dataset_prop *props;
+	const char *homedir_quota;
+	uint64_t base_user_quota;
+};
+
+static uint32_t ixnas_fs_capabilities(struct vfs_handle_struct *handle,
+			enum timestamp_set_resolution *p_ts_res)
+{
+	struct ixnas_config_data *config = NULL;
+        uint32_t fscaps;
+	int rv;
+
+	fscaps = SMB_VFS_NEXT_FS_CAPABILITIES(handle, p_ts_res);
+
+	rv = pathconf(handle->conn->connectpath,
+		      _PC_ACL_NFS4);
+	if (rv == 1) {
+		handle->conn->aclbrand = SMB_ACL_BRAND_NFS41;
+	}
+	else if (fscaps & FILE_PERSISTENT_ACLS) {
+		handle->conn->aclbrand = SMB_ACL_BRAND_POSIX;
+	}
+	else {
+		handle->conn->aclbrand = SMB_ACL_BRAND_NONE;
+	}
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return fscaps);
+
+	if (config->dosattrib_xattr) {
+		return fscaps;
+	}
+
+	rv = pathconf(handle->conn->connectpath, _PC_MIN_HOLE_SIZE);
+	if (rv > 0) {
+		DBG_DEBUG("pathconf _PC_MIN_HOLE_SIZE on [%s] returned: %d\n",
+			  handle->conn->connectpath, rv);
+		fscaps |= FILE_SUPPORTS_SPARSE_FILES;
+	}
+	DBG_INFO("ixnas: fscaps: %08x\n", fscaps);
+	return fscaps;
+}
+
+static const struct {
+	uint32_t bsdattr;
+	uint32_t dosmode;
+} bsd2dosmode[] = {
+	{ UF_READONLY, FILE_ATTRIBUTE_READONLY },
+	{ UF_ARCHIVE, FILE_ATTRIBUTE_ARCHIVE },
+	{ UF_SYSTEM, FILE_ATTRIBUTE_SYSTEM },
+	{ UF_HIDDEN, FILE_ATTRIBUTE_HIDDEN },
+	{ UF_SPARSE, FILE_ATTRIBUTE_SPARSE },
+	{ UF_OFFLINE, FILE_ATTRIBUTE_OFFLINE },
+	{ UF_REPARSE, FILE_ATTRIBUTE_REPARSE_POINT },
+};
+
+static uint32_t fileflags_to_dosmode(uint32_t fileflags)
+{
+	uint32_t dosmode = 0;
+	int i;
+	for (i = 0; i < ARRAY_SIZE(bsd2dosmode); i++) {
+		if (fileflags & bsd2dosmode[i].bsdattr) {
+			dosmode |= bsd2dosmode[i].dosmode;
+		}
+	}
+	return dosmode;
+}
+
+static uint32_t dosmode_to_fileflags(uint32_t dosmode)
+{
+	uint32_t fileflags = 0;
+	int i;
+	for (i = 0; i < ARRAY_SIZE(bsd2dosmode); i++) {
+		if (dosmode & bsd2dosmode[i].dosmode) {
+			fileflags |= bsd2dosmode[i].bsdattr;
+		}
+	}
+	return fileflags;
+}
+
+static bool check_dosmode_rights(struct connection_struct *conn,
+				 const struct smb_filename *smb_fname)
+{
+	bool rv;
+	NTSTATUS status;
+
+	if (!CAN_WRITE(conn)) {
+		return false;
+	}
+
+	status = smbd_check_access_rights(conn, conn->cwd_fsp,
+					  smb_fname, false,
+					  FILE_WRITE_ATTRIBUTES);
+	if (NT_STATUS_IS_OK(status)) {
+		rv = true;
+	}
+
+	if (!rv && lp_dos_filemode(SNUM(conn))) {
+		rv = can_write_to_file(conn, conn->cwd_fsp, smb_fname);
+	}
+	return rv;
+}
+
+static NTSTATUS ixnas_get_dos_attributes(struct vfs_handle_struct *handle,
+					 struct smb_filename *smb_fname,
+					 uint32_t *dosmode)
+{
+	struct ixnas_config_data *config = NULL;
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	if (config->dosattrib_xattr) {
+		return SMB_VFS_NEXT_GET_DOS_ATTRIBUTES(handle,
+						       smb_fname,
+						       dosmode);
+	}
+
+	*dosmode |= fileflags_to_dosmode(smb_fname->st.st_ex_flags);
+	if (S_ISDIR(smb_fname->st.st_ex_mode)) {
+	/*
+	 * Windows default behavior appears to be that the archive bit
+	 * on a directory is only explicitly set by clients. FreeBSD
+	 * sets this bit when the directory's contents are modified.
+	 */
+		*dosmode &= ~FILE_ATTRIBUTE_ARCHIVE;
+	}
+
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS ixnas_fget_dos_attributes(struct vfs_handle_struct *handle,
+                                            struct files_struct *fsp,
+                                            uint32_t *dosmode)
+{
+	struct ixnas_config_data *config = NULL;
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	if (config->dosattrib_xattr) {
+		return SMB_VFS_NEXT_FGET_DOS_ATTRIBUTES(handle,
+						        fsp,
+						        dosmode);
+	}
+
+        *dosmode |= fileflags_to_dosmode(fsp->fsp_name->st.st_ex_flags);
+	if (S_ISDIR(fsp->fsp_name->st.st_ex_mode)) {
+	/*
+	 * Windows default behavior appears to be that the archive bit
+	 * on a directory is only explicitly set by clients. FreeBSD
+	 * sets this bit when the directory's contents are modified.
+	 */
+		*dosmode &= ~FILE_ATTRIBUTE_ARCHIVE;
+	}
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS ixnas_set_dos_attributes(struct vfs_handle_struct *handle,
+					 const struct smb_filename *smb_fname,
+					 uint32_t dosmode)
+{
+	struct ixnas_config_data *config = NULL;
+	int ret;
+	uint32_t fileflags;
+	bool set_dosmode_ok;
+	NTSTATUS status;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	if (config->dosattrib_xattr) {
+		return SMB_VFS_NEXT_SET_DOS_ATTRIBUTES(handle,
+						       smb_fname,
+						       dosmode);
+	}
+	fileflags = dosmode_to_fileflags(dosmode);
+
+	DBG_INFO("ixnas:set_dos_attributes: set attribute 0x%x, on file %s\n",
+		dosmode, smb_fname->base_name);
+
+	ret = chflagsat(handle->conn->cwd_fsp->fh->fd,
+			smb_fname->base_name, fileflags, 0);
+	if (ret ==-1 && errno == EPERM) {
+		set_dosmode_ok = check_dosmode_rights(handle->conn, smb_fname);
+		if (!set_dosmode_ok){
+			return NT_STATUS_ACCESS_DENIED;
+		}
+
+		become_root();
+		ret = chflagsat(handle->conn->cwd_fsp->fh->fd,
+				smb_fname->base_name, fileflags, 0);
+		unbecome_root();
+	}
+	if (ret == -1) {
+		DBG_WARNING("Setting dosmode [0x%08x] failed for %s: %s\n",
+			    fileflags, smb_fname->base_name, strerror(errno));
+		return map_nt_error_from_unix(errno);
+	}
+
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS ixnas_fset_dos_attributes(struct vfs_handle_struct *handle,
+                                            struct files_struct *fsp,
+                                            uint32_t dosmode)
+{
+	struct ixnas_config_data *config = NULL;
+	int ret;
+	uint32_t fileflags;
+	bool set_dosmode_ok;
+	NTSTATUS status;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	if (config->dosattrib_xattr) {
+		return SMB_VFS_NEXT_FSET_DOS_ATTRIBUTES(handle,
+						        fsp,
+						        dosmode);
+	}
+
+	fileflags = dosmode_to_fileflags(dosmode);
+
+	DBG_INFO("ixnas:set_dos_attributes: set attribute 0x%x, on file %s\n",
+		dosmode, fsp_str_dbg(fsp));
+
+	ret = fchflags(fsp->fh->fd, fileflags);
+	if (ret ==-1 && errno == EPERM) {
+		set_dosmode_ok = check_dosmode_rights(handle->conn, fsp->fsp_name);
+		if (!set_dosmode_ok){
+			return NT_STATUS_ACCESS_DENIED;
+		}
+		become_root();
+		ret = fchflags(fsp->fh->fd, fileflags);
+		unbecome_root();
+	}
+	if (ret == -1) {
+		DBG_WARNING("Setting dosmode failed for %s: %s\n",
+			fsp_str_dbg(fsp), strerror(errno));
+		return map_nt_error_from_unix(errno);
+	}
+
+	return NT_STATUS_OK;
+}
+
+#if HAVE_LIBZFS
+static uint64_t ixnas_disk_free(vfs_handle_struct *handle,
+				const struct smb_filename *smb_fname,
+				uint64_t *bsize,
+				uint64_t *dfree,
+				uint64_t *dsize)
+{
+	uint64_t res;
+	char rp[PATH_MAX] = { 0 };
+	struct ixnas_config_data *config = NULL;
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return -1);
+
+	if (!config->zfs_space_enabled) {
+		return SMB_VFS_NEXT_DISK_FREE(handle, smb_fname, bsize, dfree, dsize);
+	}
+
+	if (realpath(smb_fname->base_name, rp) == NULL)
+		return (-1);
+
+	DBG_DEBUG("realpath = %s\n", rp);
+
+	res = smb_zfs_disk_free(config->libzp, rp, bsize, dfree, dsize, geteuid());
+	if (res == (uint64_t)-1)
+		res = SMB_VFS_NEXT_DISK_FREE(handle, smb_fname, bsize, dfree, dsize);
+	if (res == (uint64_t)-1)
+		return (res);
+
+	DBG_DEBUG("*bsize = %" PRIu64 "\n", *bsize);
+	DBG_DEBUG("*dfree = %" PRIu64 "\n", *dfree);
+	DBG_DEBUG("*dsize = %" PRIu64 "\n", *dsize);
+
+	return (res);
+}
+#endif
+
+/*
+ * These permissions unfortunately don't line up directly so we
+ * perform bitwise operations to transform them.
+ * BSD perms are defined in acl.h and generic NFSv4 perms in nfs4_acls.h
+ * Several permissions share the same mask (depending on whether they
+ * apply to file or directory.
+ * ____________________________   _____________________________________
+ * READ_DATA         0x00000008 | SMB_ACE4_READ_DATA         0x00000001
+ * WRITE_DATA        0x00000010 | SMB_ACE4_WRITE_DATA        0x00000002
+ * APPEND_DATA       0x00000020 | SMB_ACE4_APPEND_DATA       0x00000004
+ * READ_NAMED_ATTRS  0x00000040 | SMB_ACE4_READ_NAMED_ATTRS  0x00000008
+ * WRITE_NAMED_ATTRS 0x00000080 | SMB_ACE4_WRITE_NAMED_ATTRS 0x00000010
+ * EXECUTE               0x0001 | SMB_ACE4_EXECUTE           0x00000020
+ * DELETE_CHILD      0x00000100 | SMB_ACE4_DELETE_CHILD      0x00000040
+ * READ_ATTRIBUTES   0x00000200 | SMB_ACE4_READ_ATTRIBUTES   0x00000080
+ * WRITE_ATTRIBUTES  0x00000400 | SMB_ACE4_WRITE_ATTRIBUTES  0x00000100
+ * DELETE            0x00000800 | SMB_ACE4_DELETE            0x00010000
+ * READ_ACL          0x00001000 | SMB_ACE4_READ_ACL          0x00020000
+ * WRITE_ACL         0x00002000 | SMB_ACE4_WRITE_ACL         0x00040000
+ * WRITE_OWNER       0x00004000 | SMB_ACE4_WRITE_OWNER       0x00080000
+ * SYNCHRONIZE       0x00008000 | SMB_ACE4_SYNCHRONIZE       0x00100000
+ *
+ * Requests for GENERIC rights will fail if the ACE lacks synchronize.
+ * this means that this bit must be added to allow ACEs but not deny
+ * ACEs. See Samba bugzilla tickets #7909 and #8442.
+ */
+static uint32_t bsd2nfs4perms(acl_perm_t bsd_perm)
+{
+	uint32_t nfs4perms;
+	int l, m, h;
+
+	l = bsd_perm >> 3;
+	m = bsd_perm >> 2;
+	h = bsd_perm << 5;
+	l &= (SMB_ACE4_READ_DATA|SMB_ACE4_WRITE_DATA|
+	      SMB_ACE4_APPEND_DATA|SMB_ACE4_READ_NAMED_ATTRS|
+	      SMB_ACE4_WRITE_NAMED_ATTRS);
+	m &= (SMB_ACE4_READ_ATTRIBUTES|SMB_ACE4_WRITE_ATTRIBUTES|
+	      SMB_ACE4_DELETE_CHILD);
+	h &= (SMB_ACE4_DELETE|SMB_ACE4_READ_ACL|
+	      SMB_ACE4_WRITE_ACL|SMB_ACE4_WRITE_OWNER|
+	      SMB_ACE4_SYNCHRONIZE); //remove bits lower than SMB_ACE4_DELETE
+	nfs4perms = (l|m|h);
+	if (bsd_perm & ACL_EXECUTE) {
+		nfs4perms |= SMB_ACE4_EXECUTE;
+	}
+
+	return nfs4perms;
+}
+
+static acl_perm_t nfs42bsdperms(uint32_t nfs4perms)
+{
+	acl_perm_t bsd_perm;
+	int l, m, h;
+
+	l =  nfs4perms << 3;
+	m =  nfs4perms << 2;
+	h =  nfs4perms >> 5;
+	l &= (ACL_READ_DATA|ACL_WRITE_DATA|ACL_APPEND_DATA|
+	      ACL_READ_NAMED_ATTRS|ACL_WRITE_NAMED_ATTRS);
+	m &= (ACL_WRITE_ATTRIBUTES|ACL_READ_ATTRIBUTES|ACL_DELETE_CHILD);
+	h &= (ACL_READ_ACL|ACL_WRITE_ACL|ACL_WRITE_OWNER|ACL_DELETE); //Drop SYNCRHONIZE per#7909
+	bsd_perm = (l|m|h);
+	if (nfs4perms & SMB_ACE4_EXECUTE) {
+		bsd_perm |= ACL_EXECUTE; //0x0001 (doesn't map cleanly)
+	}
+	return bsd_perm;
+}
+
+/*
+ * FreeBSD does not use IDENTIFIER_GROUP flag.
+ * __________________________    ____________________________________________
+ * FILE_INHERIT         0x0001 | SMB_ACE4_FILE_INHERIT_ACE         0x00000001
+ * DIRECTORY_INHERIT    0x0002 | SMB_ACE4_DIRECTORY_INHERIT_ACE    0x00000002
+ * NO_PROPAGATE_INHERIT 0x0004 | SMB_ACE4_NO_PROPAGATE_INHERIT_ACE 0x00000004
+ * INHERIT_ONLY         0x0008 | SMB_ACE4_INHERIT_ONLY_ACE         0x00000008
+ * SUCCESSFUL_ACCESS    0x0010 | SMB_ACE4_SUCCESSFUL_ACCESS_FLAG   0x00000010
+ * FAILED_ACCESS        0x0020 | SMB_ACE4_FAILED_ACCESS_FLAG       0x00000020
+ * INHERITED            0x0080 | SMB_ACE4_INHERITED_ACE            0x00000080
+ *                             | SMB_ACE4_IDENTIFIER_GROUP         0x00000040
+ */
+
+static inline uint32_t bsd2nfs4flags(acl_flag_t bsd_flags)
+{
+	return (uint32_t)bsd_flags;
+}
+
+static inline uint16_t nfs42bsdflags(uint32_t nfs4flags)
+{
+	acl_flag_t bsd_flags = (acl_flag_t)nfs4flags;
+	return bsd_flags & ~SMB_ACE4_IDENTIFIER_GROUP;
+}
+
+static acl_t get_zfs_acl(const struct smb_filename *smb_fname)
+{
+	acl_t zacl;
+	int ret, saved_errno;
+	zacl = acl_get_file(smb_fname->base_name, ACL_TYPE_NFS4);
+	if (zacl == NULL) {
+		/*
+		 * If we fail to get the ACL on the path in question,
+		 * make a pathconf() call to determine whether the path
+		 * supports NFSv4 ACLs. If it does not, then it's clear that
+		 * the filesystem underly the path in question is not ZFS.
+		 * In this case we want to pass through to the next VFS module
+		 * in the stack, which will probably treat the path as having
+		 * posix ACLs. errno is set to ENOSYS in this case because
+		 * neither pathconf() nor acl_get_file() set it to this value, and
+		 * because this is the behavior of libsunacl / vfs_zfsacl.
+		 */
+		saved_errno = errno;
+		ret = pathconf(smb_fname->base_name, _PC_ACL_NFS4);
+		if (ret != 0) {
+			/*
+			 * If path does not support NFS4 ACLs, then pathconf() returns -1
+			 * and errno is not modified. If pathconf() itself fails, then it
+			 * returns -1 and errno is set.
+			 */
+			if (errno != saved_errno) {
+				DBG_INFO("%s: pathconf(..., _PC_ACL_NFS4) failed. Path does not support NFS4 ACL.",
+					smb_fname->base_name);
+				errno = ENOSYS;
+			}
+			else {
+				DBG_INFO("ixnas: pathconf() failed for %s: %s\n",
+					smb_fname->base_name, strerror(errno));
+			}
+		}
+	}
+	return zacl;
+}
+
+static acl_t fget_zfs_acl(struct files_struct *fsp)
+{
+	acl_t zacl;
+	int ret, saved_errno;
+	if (fsp->fh->fd == -1) {
+		return get_zfs_acl(fsp->fsp_name);
+	}
+	zacl = acl_get_fd_np(fsp->fh->fd, ACL_TYPE_NFS4);
+
+	if (zacl == NULL) {
+		/* See above note in get_zfs_acl() */
+		saved_errno = errno;
+		ret = fpathconf(fsp->fh->fd, _PC_ACL_NFS4);
+		if (ret != 0) {
+			/*
+			 * If path does not support NFS4 ACLs, then pathconf() returns -1
+			 * and errno is not modified. If pathconf() itself fails, then it
+			 * returns -1 and errno is set.
+			 */
+			if (errno != saved_errno) {
+				DBG_INFO("%s: pathconf(..., _PC_ACL_NFS4) failed. Path does not support NFS4 ACL.",
+					 fsp->fsp_name->base_name);
+				errno = ENOSYS;
+			}
+			else {
+				DBG_INFO("ixnas: pathconf() failed for %s: %s\n",
+					 fsp->fsp_name->base_name, strerror(errno));
+			}
+		}
+	}
+	return zacl;
+}
+
+static void map_modify(uint32_t *pperm) {
+	if (*pperm & SMB_ACE4_WRITE_DATA) {
+		*pperm |= SMB_ACE4_WRITE_NAMED_ATTRS|SMB_ACE4_WRITE_ATTRIBUTES;
+	}
+}
+
+static NTSTATUS get_nfs4_acl_common(TALLOC_CTX *mem_ctx,
+				    struct ixnas_config_data *config,
+				    acl_t bsdacl,
+				    struct SMB4ACL_T **ppacl)
+{
+	int i;
+	struct SMB4ACL_T *pacl;
+	bool inherited_is_present = false;
+	SMB_ACE4PROP_T aceprop;
+	struct acl_entry ae;
+
+	pacl = smb_create_smb4acl(mem_ctx);
+	if (pacl == NULL) {
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	for (i = 0; i < bsdacl->ats_acl.acl_cnt; i++) {
+		ae = bsdacl->ats_acl.acl_entry[i];
+		aceprop.aceFlags = bsd2nfs4flags(ae.ae_flags);
+		aceprop.aceMask = bsd2nfs4perms(ae.ae_perm);
+
+		if (ae.ae_entry_type == ACL_ENTRY_TYPE_ALLOW) {
+			aceprop.aceType = SMB_ACE4_ACCESS_ALLOWED_ACE_TYPE;
+			aceprop.aceMask |= SMB_ACE4_SYNCHRONIZE;
+		}
+		else if (ae.ae_entry_type == ACL_ENTRY_TYPE_DENY) {
+			aceprop.aceType = SMB_ACE4_ACCESS_DENIED_ACE_TYPE;
+		}
+		else if (ae.ae_entry_type == ACL_ENTRY_TYPE_AUDIT) {
+			aceprop.aceType = SMB_ACE4_SYSTEM_AUDIT_ACE_TYPE;
+		}
+		else if (ae.ae_entry_type == ACL_ENTRY_TYPE_ALARM) {
+			aceprop.aceType = SMB_ACE4_SYSTEM_ALARM_ACE_TYPE;
+		}
+		else {
+			DBG_ERR("Filesystem returned unknown ae_entry_type: "
+				"0x%08x\n", ae.ae_entry_type);
+			smb_panic("Unknown ae_entry_type");
+		}
+
+		aceprop.who.id = ae.ae_id; /* -1 in case of special entries */
+
+		switch(ae.ae_tag) {
+		case ACL_USER_OBJ: /* owner@ */
+			aceprop.flags = SMB_ACE4_ID_SPECIAL;
+			aceprop.who.special_id = SMB_ACE4_WHO_OWNER;
+			if (config->map_modify) {
+				map_modify(&aceprop.aceMask);
+			}
+			break;
+		case ACL_GROUP_OBJ: /* group@ */
+			aceprop.flags = SMB_ACE4_ID_SPECIAL;
+			aceprop.who.special_id = SMB_ACE4_WHO_GROUP;
+			if (config->map_modify) {
+				map_modify(&aceprop.aceMask);
+			}
+			break;
+		case ACL_GROUP:
+			aceprop.aceFlags |= SMB_ACE4_IDENTIFIER_GROUP;
+		case ACL_USER:
+			aceprop.flags = 0;
+			break;
+		case ACL_EVERYONE:
+			aceprop.flags = SMB_ACE4_ID_SPECIAL;
+			aceprop.who.special_id = SMB_ACE4_WHO_EVERYONE;
+			if (ae.ae_perm == 0) {
+				continue;
+			}
+			if (config->map_modify) {
+				map_modify(&aceprop.aceMask);
+			}
+			break;
+		case ACL_UNDEFINED_TAG:
+		default:
+			DBG_ERR("Enountered unknown ACL tag [0x%08x].\n",
+				ae.ae_id);
+			smb_panic("Unknown ACL tag");
+		}
+
+		if (aceprop.aceFlags & SMB_ACE4_INHERITED_ACE) {
+			inherited_is_present = true;
+		}
+		if (smb_add_ace4(pacl, &aceprop) == NULL) {
+			return NT_STATUS_NO_MEMORY;
+		}
+	}
+	if (!inherited_is_present) {
+		smbacl4_set_controlflags(pacl,
+					 SEC_DESC_DACL_PROTECTED |
+					 SEC_DESC_SELF_RELATIVE);
+	}
+	*ppacl = pacl;
+	return NT_STATUS_OK;
+}
+
+static bool process_bsd_acl(vfs_handle_struct *handle,
+			    files_struct *fsp,
+			    struct SMB4ACL_T *smbacl)
+{
+	int naces, i, rv, saved_errno;
+	acl_t bsdacl;
+	acl_entry_t hidden, new_entry;
+	SMB_ACE4PROP_T *aceprop = NULL;
+	struct SMB4ACE_T *smbace = NULL;
+
+	acl_perm_t permset;
+	acl_entry_type_t atype;
+	acl_flag_t flags;
+	uid_t id;
+	acl_tag_t tag;
+
+	naces = smb_get_naces(smbacl);
+	bsdacl = acl_init(ACL_MAX_ENTRIES);
+	if (bsdacl == NULL) {
+		DBG_ERR("Failed to initialize BSD ACL: %s\n",
+			strerror(errno));
+		return false;
+	}
+
+	for (smbace = smb_first_ace4(smbacl), i = 0;
+	     smbace != NULL;
+	     smbace = smb_next_ace4(smbace), i++) {
+
+		aceprop = smb_get_ace4(smbace);
+		switch(aceprop->aceType) {
+		case SMB_ACE4_ACCESS_ALLOWED_ACE_TYPE:
+			atype = ACL_ENTRY_TYPE_ALLOW;
+			break;
+		case SMB_ACE4_ACCESS_DENIED_ACE_TYPE:
+			atype = ACL_ENTRY_TYPE_DENY;
+			break;
+		case SMB_ACE4_SYSTEM_AUDIT_ACE_TYPE:
+			atype = ACL_ENTRY_TYPE_AUDIT;
+			DBG_ERR("Audit entries are not currently "
+				"implemented in FreeBSD.\n");
+			break;
+		case SMB_ACE4_SYSTEM_ALARM_ACE_TYPE:
+			atype = ACL_ENTRY_TYPE_ALARM;
+			DBG_ERR("Alarm entries are not currently "
+				"implemented in FreeBSD.\n");
+			break;
+		default:
+			DBG_ERR("Received unsupported entry try: [0x%08x]\n",
+				aceprop->aceType);
+			errno = EINVAL;
+			acl_free(bsdacl);
+			return false;
+		}
+
+		flags = nfs42bsdflags(aceprop->aceFlags);
+		permset = nfs42bsdperms(aceprop->aceMask);
+
+		if (aceprop->flags & SMB_ACE4_ID_SPECIAL) {
+			id = ACL_UNDEFINED_ID;
+			switch(aceprop->who.special_id) {
+			case SMB_ACE4_WHO_EVERYONE:
+				tag = ACL_EVERYONE;
+				break;
+			case SMB_ACE4_WHO_OWNER:
+				tag = ACL_USER_OBJ;
+				break;
+			case SMB_ACE4_WHO_GROUP:
+				tag = ACL_GROUP_OBJ;
+				break;
+			default:
+				DBG_ERR("Unsupported special_id %d "
+					"on ACL entry %d on file [%s]\n",
+					aceprop->who.special_id, i,
+					fsp_str_dbg(fsp));
+				errno = EINVAL;
+				acl_free(bsdacl);
+				return false;
+			}
+		}
+		else {
+			if (flags & SMB_ACE4_IDENTIFIER_GROUP) {
+				tag = ACL_GROUP;
+			}
+			else {
+				tag = ACL_USER;
+			}
+		}
+		rv = acl_create_entry(&bsdacl, &new_entry);
+		if (rv < 0) {
+			DBG_ERR("Failed to add ACL entry [%d] "
+				"for file [%s]: [%s]. Existing ACL "
+				"was not modified.\n", i,
+				fsp_str_dbg(fsp), strerror(errno));
+			smb_panic("Failed to add ACL entry");
+		}
+		new_entry->ae_perm = permset;
+		new_entry->ae_flags = flags;
+		new_entry->ae_entry_type = atype;
+		new_entry->ae_tag = tag;
+		new_entry->ae_id = id;
+	}
+	SMB_ASSERT(i == naces);
+
+	if (S_ISDIR(fsp->fsp_name->st.st_ex_mode)) {
+		rv = acl_create_entry(&bsdacl, &hidden);
+		if (rv < 0) {
+		}
+		hidden->ae_flags = ACL_ENTRY_DIRECTORY_INHERIT|
+				   ACL_ENTRY_FILE_INHERIT;
+		hidden->ae_perm = 0;
+		hidden->ae_entry_type = ACL_ENTRY_TYPE_ALLOW;
+		hidden->ae_tag = ACL_EVERYONE;
+		hidden->ae_id = ACL_UNDEFINED_ID;
+	}
+
+	rv = acl_set_fd_np(fsp->fh->fd, bsdacl, ACL_TYPE_NFS4);
+	acl_free(bsdacl);
+	if (rv != 0) {
+		if (errno == EINVAL) {
+			saved_errno = errno;
+			rv = fpathconf(fsp->fh->fd, _PC_ACL_NFS4);
+			if (rv ==  0) {
+				DBG_INFO("Filesystem for path [%s] does "
+					 "not support NFSv4 ACLs.\n",
+					 fsp_str_dbg(fsp));
+				errno = ENOSYS;
+				return false;
+			}
+			errno = saved_errno;
+		}
+		DBG_ERR("acl_set_fd_np() failed on path [%s]: %s\n",
+			fsp_str_dbg(fsp), strerror(errno));
+		return false;
+	}
+	return true;
+}
+
+/*
+ * Convert the Security Descriptor DACL into a ZFS ACL
+ * using FreeBSD nfsv4 ACL API.
+ */
+static NTSTATUS ixnas_fset_nt_acl(vfs_handle_struct *handle,
+				  files_struct *fsp,
+				  uint32_t security_info_sent,
+				  const struct security_descriptor *psd)
+{
+	struct ixnas_config_data *config = NULL;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	return smb_set_nt_acl_nfs4(handle, fsp,
+				   &config->nfs4_params,
+				   security_info_sent,
+				   psd,
+				   process_bsd_acl);
+}
+
+static NTSTATUS ixnas_fget_nt_acl(struct vfs_handle_struct *handle,
+				   struct files_struct *fsp,
+				   uint32_t security_info,
+				   TALLOC_CTX *mem_ctx,
+				   struct security_descriptor **ppdesc)
+{
+	struct SMB4ACL_T *pacl = NULL;
+	TALLOC_CTX *frame = NULL;
+	NTSTATUS status;
+	acl_t bsdacl;
+	struct ixnas_config_data *config = NULL;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+	bsdacl = fget_zfs_acl(fsp);
+	if (bsdacl == NULL) {
+		if (errno == ENOSYS) {
+			status = SMB_VFS_NEXT_FGET_NT_ACL(handle,
+							  fsp,
+							  security_info,
+							  mem_ctx, ppdesc);
+			if (NT_STATUS_IS_OK(status)) {
+				(*ppdesc)->type |= SEC_DESC_DACL_PROTECTED;
+			}
+			return status;
+		}
+		else {
+			return map_nt_error_from_unix(errno);
+		}
+	}
+
+	frame = talloc_stackframe();
+	status = get_nfs4_acl_common(frame, config, bsdacl, &pacl);
+	acl_free(bsdacl);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(frame);
+		return status;
+	}
+
+	status = smb_fget_nt_acl_nfs4(fsp, NULL, security_info,
+				      mem_ctx, ppdesc, pacl);
+	TALLOC_FREE(frame);
+	return status;
+}
+
+static NTSTATUS ixnas_get_nt_acl_at(struct vfs_handle_struct *handle,
+				struct files_struct *dirfsp,
+				const struct smb_filename *smb_fname,
+				uint32_t security_info,
+				TALLOC_CTX *mem_ctx,
+				struct security_descriptor **ppdesc)
+{
+	struct SMB4ACL_T *pacl = NULL;
+	TALLOC_CTX *frame = NULL;
+	NTSTATUS status;
+	acl_t bsdacl;
+	struct ixnas_config_data *config = NULL;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return NT_STATUS_INTERNAL_ERROR);
+
+        SMB_ASSERT(dirfsp == dirfsp->conn->cwd_fsp);
+
+	bsdacl = get_zfs_acl(smb_fname);
+	if (bsdacl == NULL) {
+		if (errno == ENOSYS) {
+			status = SMB_VFS_NEXT_GET_NT_ACL_AT(handle,
+							    dirfsp,
+							    smb_fname,
+							    security_info,
+							    mem_ctx, ppdesc);
+			if (NT_STATUS_IS_OK(status)) {
+				(*ppdesc)->type |= SEC_DESC_DACL_PROTECTED;
+			}
+			return status;
+		}
+		else {
+			return map_nt_error_from_unix(errno);
+		}
+	}
+
+	frame = talloc_stackframe();
+	status = get_nfs4_acl_common(frame, config, bsdacl, &pacl);
+	acl_free(bsdacl);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		TALLOC_FREE(frame);
+		return status;
+	}
+	status = smb_get_nt_acl_nfs4(handle->conn,
+				     smb_fname,
+				     NULL,
+				     security_info,
+				     mem_ctx,
+				     ppdesc,
+				     pacl);
+	TALLOC_FREE(frame);
+	return status;
+}
+
+/*
+ * Functions below are related to posix1e ACLs. Logic copied from vfs_zfsacl.
+ */
+static SMB_ACL_T ixnas_fail__sys_acl_get_file(vfs_handle_struct *handle,
+					const struct smb_filename *smb_fname,
+					SMB_ACL_TYPE_T type,
+					TALLOC_CTX *mem_ctx)
+{
+	return (SMB_ACL_T)NULL;
+}
+
+static SMB_ACL_T ixnas_fail__sys_acl_get_fd(vfs_handle_struct *handle,
+					     files_struct *fsp,
+					     TALLOC_CTX *mem_ctx)
+{
+	return (SMB_ACL_T)NULL;
+}
+
+static int ixnas_fail__sys_acl_set_file(vfs_handle_struct *handle,
+					 const struct smb_filename *smb_fname,
+					 SMB_ACL_TYPE_T type,
+					 SMB_ACL_T theacl)
+{
+	return -1;
+}
+
+static int ixnas_fail__sys_acl_set_fd(vfs_handle_struct *handle,
+				       files_struct *fsp,
+				       SMB_ACL_T theacl)
+{
+	return -1;
+}
+
+static int ixnas_fail__sys_acl_delete_def_file(vfs_handle_struct *handle,
+			const struct smb_filename *smb_fname)
+{
+	return -1;
+}
+
+static int ixnas_fail__sys_acl_blob_get_file(vfs_handle_struct *handle,
+			const struct smb_filename *smb_fname,
+			TALLOC_CTX *mem_ctx,
+			char **blob_description,
+			DATA_BLOB *blob)
+{
+	return -1;
+}
+
+static int ixnas_fail__sys_acl_blob_get_fd(vfs_handle_struct *handle,
+			files_struct *fsp,
+			TALLOC_CTX *mem_ctx,
+			char **blob_description,
+			DATA_BLOB *blob)
+{
+	return -1;
+}
+
+#if HAVE_LIBZFS
+/********************************************************************
+  Expose ZFS user/group quotas
+********************************************************************/
+static int ixnas_get_quota(struct vfs_handle_struct *handle,
+                                const struct smb_filename *smb_fname,
+                                enum SMB_QUOTA_TYPE qtype,
+                                unid_t id,
+                                SMB_DISK_QUOTA *qt)
+
+{
+	int ret;
+	char rp[PATH_MAX] = { 0 };
+	struct ixnas_config_data *config = NULL;
+	uint64_t hardlimit, usedspace;
+	uid_t current_user = geteuid();
+	hardlimit = usedspace = 0;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return -1);
+
+	if (!config->zfs_quota_enabled) {
+		DBG_DEBUG("Quotas disabled in ixnas configuration.\n");
+		errno = ENOSYS;
+		return -1;
+	}
+
+	if (realpath(smb_fname->base_name, rp) == NULL) {
+		DBG_ERR("failed to get realpath for (%s)\n", smb_fname->base_name);
+		return (-1);
+	}
+	switch (qtype) {
+	case SMB_USER_QUOTA_TYPE:
+	case SMB_USER_FS_QUOTA_TYPE:
+		//passing -1 to quotactl means that the current UID should be used. Do the same.
+		if (id.uid == -1) {
+			become_root();
+			ret = smb_zfs_get_userspace_quota(config->libzp,
+							  rp, current_user,
+							  qtype, &hardlimit, &usedspace);
+			unbecome_root();
+		}
+		else {
+			become_root();
+			ret = smb_zfs_get_userspace_quota(config->libzp,
+							  rp, id.uid, qtype,
+							  &hardlimit, &usedspace);
+			unbecome_root();
+		}
+		break;
+	case SMB_GROUP_QUOTA_TYPE:
+	case SMB_GROUP_FS_QUOTA_TYPE:
+		become_root();
+		ret = smb_zfs_get_userspace_quota(config->libzp,
+						  rp, id.gid, qtype,
+						  &hardlimit, &usedspace);
+		unbecome_root();
+		break;
+	default:
+		DBG_ERR("Unrecognized quota type.\n");
+		ret = -1;
+		break;
+	}
+
+	ZERO_STRUCTP(qt);
+	qt->bsize = 1024;
+	qt->hardlimit = hardlimit;
+	qt->softlimit = hardlimit;
+	qt->curblocks = usedspace;
+	qt->ihardlimit = hardlimit;
+	qt->isoftlimit = hardlimit;
+	qt->curinodes = usedspace;
+	qt->qtype = qtype;
+	qt->qflags = QUOTAS_DENY_DISK|QUOTAS_ENABLED;
+
+        DBG_INFO("ixnas_get_quota: hardlimit: (%lu), usedspace: (%lu)\n", qt->hardlimit, qt->curblocks);
+
+        return ret;
+}
+
+static int ixnas_set_quota(struct vfs_handle_struct *handle,
+			enum SMB_QUOTA_TYPE qtype, unid_t id,
+			SMB_DISK_QUOTA *qt)
+{
+	struct ixnas_config_data *config = NULL;
+	int ret;
+	bool is_disk_op = false;
+
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return -1);
+
+	if (!config->zfs_quota_enabled) {
+		DBG_DEBUG("Quotas disabled in ixnas configuration.\n");
+		errno = ENOSYS;
+		return -1;
+	}
+
+	is_disk_op = security_token_has_privilege(
+			handle->conn->session_info->security_token,
+			SEC_PRIV_DISK_OPERATOR);
+
+	if (!is_disk_op) {
+		errno = EPERM;
+		return -1;
+	}
+
+	switch (qtype) {
+	case SMB_USER_QUOTA_TYPE:
+	case SMB_USER_FS_QUOTA_TYPE:
+		DBG_INFO("ixnas_set_quota: quota type: (%d), "
+			 "id: (%d), h-limit: (%lu), s-limit: (%lu)\n",
+			 qtype, id.uid, qt->hardlimit, qt->softlimit);
+		become_root();
+		ret = smb_zfs_set_userspace_quota(config->libzp,
+						  handle->conn->connectpath,
+						  id.uid, qtype, qt->hardlimit);
+		unbecome_root();
+		break;
+	case SMB_GROUP_QUOTA_TYPE:
+	case SMB_GROUP_FS_QUOTA_TYPE:
+		DBG_INFO("ixnas_set_quota: quota type: (%d), "
+			 "id: (%d), h-limit: (%lu), s-limit: (%lu)\n",
+			 qtype, id.gid, qt->hardlimit, qt->softlimit);
+		become_root();
+		ret = smb_zfs_set_userspace_quota(config->libzp,
+						  handle->conn->connectpath,
+						  id.gid, qtype, qt->hardlimit);
+		unbecome_root();
+		break;
+	default:
+		DBG_ERR("Received unknown quota type.\n");
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+/********************************************************************
+ Convert chmod() requests into an appropriate non-inheriting ACL
+ entry. We don't rely on FreeBSD kernel behavior in this case,
+ because it strips some bits that we actually care about
+ (WRITE_ATTRIBUTES, DELETE, etc.). If DELETE is stripped, then
+ users will no longer be able to rename files.
+********************************************************************/
+static int mode_to_acl(acl_t *new_acl, mode_t mode)
+{
+	int res = 0;
+	mode_t shifted_mode, other_mode, deny_mode;
+	acl_entry_t o_allow_entry = NULL;
+	acl_entry_t g_allow_entry = NULL;
+	acl_entry_t e_allow_entry = NULL;
+	acl_entry_t o_deny_entry = NULL;
+	acl_entry_t g_deny_entry = NULL;
+	acl_permset_t permset;
+	acl_flagset_t flagset;
+	/*
+	 * convert posix mode bits to ACLs
+	 */
+	if (((mode & S_IRWXU) >> 6) < (mode & S_IRWXO)) {
+		shifted_mode = (mode &= S_IRWXU) >> 6;
+		other_mode &= S_IRWXO;
+		deny_mode = (shifted_mode ^ other_mode) << 6;
+		res = acl_create_entry(new_acl, &o_deny_entry);
+		if (res != 0) {
+			return -1;
+		}
+		acl_get_permset(o_deny_entry, &permset);
+		if (deny_mode & S_IRUSR) {
+			*permset = ACL_READ_DATA;
+		}
+		if (deny_mode & S_IWUSR) {
+			*permset |= ACL_WRITE_DATA;
+		}
+		if (deny_mode & S_IXUSR) {
+			*permset |= ACL_EXECUTE;
+		}
+		acl_get_flagset_np(o_deny_entry, &flagset);
+		*flagset = 0;
+		acl_set_entry_type_np(o_deny_entry, ACL_ENTRY_TYPE_DENY);
+		acl_set_tag_type(o_deny_entry, ACL_USER_OBJ);
+	}
+	if (((mode & S_IRWXG) >> 3) < (mode & S_IRWXO)) {
+		shifted_mode = (mode &= S_IRWXG) >> 3;
+		other_mode &= S_IRWXG;
+		deny_mode = (shifted_mode ^ other_mode) << 3;
+
+		res = acl_create_entry(new_acl, &g_deny_entry);
+		if (res != 0) {
+			return -1;
+		}
+		acl_get_permset(g_deny_entry, &permset);
+		if (deny_mode & S_IRGRP) {
+			*permset = ACL_READ_DATA;
+		}
+		if (deny_mode & S_IWGRP) {
+			*permset |= ACL_WRITE_DATA;
+		}
+		if (deny_mode & S_IXGRP) {
+			*permset |= ACL_EXECUTE;
+		}
+		acl_get_flagset_np(g_deny_entry, &flagset);
+		*flagset = 0;
+		acl_set_entry_type_np(g_deny_entry, ACL_ENTRY_TYPE_DENY);
+		acl_set_tag_type(g_deny_entry, ACL_GROUP_OBJ);
+	}
+	if (mode & S_IRWXU) {
+		res = acl_create_entry(new_acl, &o_allow_entry);
+		if (res != 0) {
+			return -1;
+		}
+		acl_get_permset(o_allow_entry, &permset);
+		if (mode & S_IRUSR) {
+			*permset = ACL_READ_SET;
+		}
+		if (mode & S_IWUSR) {
+			*permset |= ACL_WRITE_SET;
+			*permset |= ACL_DELETE;
+		}
+		if (mode & S_IXUSR) {
+			*permset |= ACL_EXECUTE;
+		}
+		acl_get_flagset_np(o_allow_entry, &flagset);
+		*flagset = 0;
+		acl_set_entry_type_np(o_allow_entry, ACL_ENTRY_TYPE_ALLOW);
+		acl_set_tag_type(o_allow_entry, ACL_USER_OBJ);
+	}
+	if (mode & S_IRWXG) {
+		res = acl_create_entry(new_acl, &g_allow_entry);
+		if (res != 0) {
+			return -1;
+		}
+		acl_get_permset(g_allow_entry, &permset);
+		if (mode & S_IRGRP) {
+			*permset = ACL_READ_SET;
+		}
+		if (mode & S_IWGRP) {
+			*permset |= ACL_WRITE_SET;
+			*permset |= ACL_DELETE;
+		}
+		if (mode & S_IXGRP) {
+			*permset |= ACL_EXECUTE;
+		}
+		acl_get_flagset_np(g_allow_entry, &flagset);
+		*flagset = 0;
+		acl_set_entry_type_np(g_allow_entry, ACL_ENTRY_TYPE_ALLOW);
+		acl_set_tag_type(g_allow_entry, ACL_GROUP_OBJ);
+	}
+	if (mode & S_IRWXO) {
+		res = acl_create_entry(new_acl, &e_allow_entry);
+		if (res != 0) {
+			return -1;
+		}
+		acl_get_permset(e_allow_entry, &permset);
+		if (mode & S_IROTH) {
+			*permset = ACL_READ_SET;
+		}
+		if (mode & S_IWOTH) {
+			*permset |= ACL_WRITE_SET;
+			*permset |= ACL_DELETE;
+		}
+		if (mode & S_IXOTH) {
+			*permset |= ACL_EXECUTE;
+		}
+		acl_get_flagset_np(e_allow_entry, &flagset);
+		*flagset = 0;
+		acl_set_entry_type_np(e_allow_entry, ACL_ENTRY_TYPE_ALLOW);
+		acl_set_tag_type(e_allow_entry, ACL_EVERYONE);
+	}
+	return 0;
+}
+
+static int recalculate_flagset(acl_flagset_t flagset)
+{
+	/* Simply replace non-inheriting entries */
+	if ((*flagset & (ACL_ENTRY_DIRECTORY_INHERIT \
+		        | ACL_ENTRY_FILE_INHERIT)) == 0){
+		return -1;
+	}
+	/*
+	 * This edge case is not easily handled. It is
+	 * unclear what user expectation should be. FreeBSD
+	 * kernel changes to fdin, but this causes the ACL
+	 * to inherit one deeper than it should. I think safe
+	 * play here is to maintain the inheritance flags
+	 * as-is and end up with wonky mode so as not to
+	 * break expectations regarding inheritance.
+	 */
+	if (((*flagset & ACL_ENTRY_INHERIT_ONLY) == 0) &&
+	     (*flagset & ACL_ENTRY_NO_PROPAGATE_INHERIT)) {
+		return 0;
+	}
+	*flagset |= ACL_ENTRY_INHERIT_ONLY;
+	return 0;
+}
+
+static acl_t calculate_chmod_acl(acl_t source_acl,
+				 mode_t mode)
+{
+	int res = 0;
+	acl_t new_acl, tmp_acl;
+	int entry_id = ACL_FIRST_ENTRY;
+	acl_entry_t entry, new_entry;
+	acl_tag_t tag = 0;
+	acl_flagset_t flagset;
+
+	new_acl = acl_init(ACL_MAX_ENTRIES);
+	tmp_acl = acl_dup(source_acl);
+	res = mode_to_acl(&new_acl, mode);
+	if (res != 0) {
+		DBG_ERR("Failed to convert mode to ACL\n");
+		goto failure;
+	}
+	/*
+	 * Iterate through ACL, remove non-inheriting special entries.
+	 * Append INHERIT_ONLY to inheritng special entries
+	 */
+	while (acl_get_entry(tmp_acl, entry_id, &entry) == 1) {
+		entry_id = ACL_NEXT_ENTRY;
+		res = acl_get_tag_type(entry, &tag);
+		if (res != 0) {
+			DBG_ERR("acl_get_permset() failed.\n");
+			return NULL;
+		}
+		switch (tag) {
+                        case ACL_USER_OBJ:
+                        case ACL_GROUP_OBJ:
+                        case ACL_EVERYONE:
+				res = acl_get_flagset_np(entry, &flagset);
+				if (res != 0) {
+					DBG_ERR("acl_get_flagset failed\n");
+					return NULL;
+				}
+				res = recalculate_flagset(flagset);
+				if (res != 0) {
+					continue;
+				}
+				res = acl_create_entry(&new_acl, &new_entry);
+				if (res != 0) {
+					DBG_ERR("acl_create_entry failed\n");
+					goto failure;
+				}
+				res = acl_copy_entry(new_entry, entry);
+				if (res != 0) {
+					DBG_ERR("acl_copy_entry failed\n");
+					goto failure;
+				}
+                                break;
+                        default:
+				res = acl_create_entry(&new_acl, &new_entry);
+				if (res != 0) {
+					DBG_ERR("acl_create_entry failed\n");
+					goto failure;
+				}
+				res = acl_copy_entry(new_entry, entry);
+				if (res != 0) {
+					DBG_ERR("acl_copy_entry failed\n");
+					goto failure;
+				}
+                                break;
+		}
+	}
+	acl_free(tmp_acl);
+	return new_acl;
+failure:
+	acl_free(tmp_acl);
+	acl_free(new_acl);
+	return NULL;
+}
+
+static int ixnas_chmod(vfs_handle_struct *handle,
+		       const struct smb_filename *smb_fname,
+		       mode_t mode)
+{
+	int result;
+	acl_t zacl, new_acl;
+	int trivial = 0;
+	struct ixnas_config_data *config = NULL;
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return -1);
+
+	if (!config->zfs_acl_chmod_enabled) {
+		return SMB_VFS_NEXT_CHMOD(handle, smb_fname, mode);
+	}
+	zacl = acl_get_file(smb_fname->base_name, ACL_TYPE_NFS4);
+	if (zacl == NULL) {
+		DBG_ERR("ixnas: acl_get_file() failed for %s: %s\n",
+			smb_fname->base_name, strerror(errno));
+		return -1;
+	}
+	result = acl_is_trivial_np(zacl, &trivial);
+	if (result !=0) {
+		DBG_ERR("acl_is_trivial_np() failed\n");
+		goto failure;
+	}
+	/*
+	 * A "trivial" ACL can be expressed as a POSIX mode without
+	 * losing information. In this case, pass on to normal
+	 * chmod() behavior because user is probably not concerned
+	 * about ACLs.
+	 */
+	if (trivial) {
+		DBG_INFO("Trivial ACL detected on file %s, "
+			 "passing to next CHMOD function\n",
+			 smb_fname->base_name);
+		acl_free(zacl);
+		result = SMB_VFS_NEXT_CHMOD(handle, smb_fname, mode);
+		return result;
+	}
+	new_acl = calculate_chmod_acl(zacl, mode);
+	if (new_acl == NULL) {
+		DBG_ERR("Failed to generate new ACL for %s: %s\n",
+			smb_fname->base_name, strerror(errno));
+		goto failure;
+	}
+	result = acl_set_file(smb_fname->base_name, ACL_TYPE_NFS4, new_acl);
+	if (result != 0) {
+		DBG_ERR("Failed to set new ACL on %s: %s\n",
+			smb_fname->base_name, strerror(errno));
+		acl_free(new_acl);
+		goto failure;
+	}
+	acl_free(zacl);
+	acl_free(new_acl);
+	return result;
+
+failure:
+	acl_free(zacl);
+	return -1;
+}
+
+static int ixnas_fchmod(vfs_handle_struct *handle,
+			files_struct *fsp, mode_t mode)
+{
+	int result;
+	acl_t zacl, new_acl;
+	int trivial = 0;
+	struct ixnas_config_data *config = NULL;
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return -1);
+
+	if (!config->zfs_acl_chmod_enabled) {
+		return SMB_VFS_NEXT_FCHMOD(handle, fsp, mode);
+	}
+	zacl = acl_get_fd_np(fsp->fh->fd, ACL_TYPE_NFS4);
+	if (zacl == NULL) {
+		DBG_ERR("ixnas: acl_get_fd() failed for %s: %s\n",
+			fsp_str_dbg(fsp), strerror(errno));
+		return -1;
+	}
+	result = acl_is_trivial_np(zacl, &trivial);
+	if (result !=0) {
+		DBG_ERR("acl_is_trivial_np() failed\n");
+		goto failure;
+	}
+	/*
+	 * A "trivial" ACL can be expressed as a POSIX mode without
+	 * losing information. In this case, pass on to normal
+	 * chmod() behavior because user is probably not concerned
+	 * about ACLs.
+	 */
+	if (trivial) {
+		DBG_INFO("Trivial ACL detected on file %s, "
+			 "passing to next CHMOD function\n",
+			 fsp_str_dbg(fsp));
+		acl_free(zacl);
+		result = SMB_VFS_NEXT_FCHMOD(handle, fsp, mode);
+		return result;
+	}
+	new_acl = calculate_chmod_acl(zacl, mode);
+	if (new_acl == NULL) {
+		DBG_ERR("Failed to generate new ACL for %s",
+			fsp_str_dbg(fsp));
+		goto failure;
+	}
+	result = acl_set_fd_np(fsp->fh->fd, new_acl, ACL_TYPE_NFS4);
+	if (result != 0) {
+		DBG_ERR("Failed to set new ACL on %s: %s\n",
+			fsp_str_dbg(fsp), strerror(errno));
+		acl_free(new_acl);
+		goto failure;
+	}
+	acl_free(zacl);
+	acl_free(new_acl);
+	return result;
+failure:
+	acl_free(zacl);
+	return -1;
+}
+/********************************************************************
+ Create datasets for home directories. We fail if the path already
+ exists
+********************************************************************/
+
+static acl_t calculate_inherited_acl(acl_t parent_acl)
+{
+	acl_t tmp_acl;
+	acl_t new_acl = NULL;
+	int trivial = 0;
+	acl_entry_t entry, dir_entry;
+	acl_permset_t permset;
+	acl_flagset_t flagset, dir_flag;
+	int entry_id, d_entry_id;
+	entry_id = d_entry_id = ACL_FIRST_ENTRY;
+	if (acl_is_trivial_np(parent_acl, &trivial) != 0) {
+		DBG_ERR("acl_is_trivial_np() failed\n");
+		return NULL;
+	}
+	if (trivial) {
+		DBG_ERR("ACL is trivial, not calculating inherited ACL\n");
+		return parent_acl;
+	}
+	if ((new_acl = acl_init(ACL_MAX_ENTRIES)) == NULL) {
+		DBG_ERR("Failed to initialize new ACL for connectpath.\n");
+		return NULL;
+	}
+	tmp_acl = acl_dup(parent_acl);
+	while (acl_get_entry(tmp_acl, entry_id, &entry) == 1) {
+		entry_id = ACL_NEXT_ENTRY;
+		if (acl_get_permset(entry, &permset)) {
+			DBG_ERR("acl_get_permset() failed on connectpath.\n");
+			goto failure;
+		}
+		if (acl_get_flagset_np(entry, &flagset)) {
+			DBG_ERR("acl_get_flagset_np() failed\n");
+			goto failure;
+		}
+		/* Entry is not inheritable at all. Skip. */
+		if ((*flagset & (ACL_ENTRY_DIRECTORY_INHERIT|ACL_ENTRY_FILE_INHERIT)) == 0) {
+			continue;
+		}
+		/* Skip if the ACE has NO_PROPAGATE flag set and does not have INHERIT_ONLY flag. */
+		if ((*flagset & ACL_ENTRY_NO_PROPAGATE_INHERIT) &&
+		    (*flagset & ACL_ENTRY_INHERIT_ONLY) == 0) {
+			continue;
+		}
+
+		/*
+		 * Skip if the ACE has NO_PROPAGATE flag set and does not have DIRECTORY INHERIT.
+		 * This is acceptible in this limited case of calculating inherited ACLs on
+		 * child datasets. We know that the ACL generated here will not be applied to a file.
+		 */
+		if ((*flagset & ACL_ENTRY_NO_PROPAGATE_INHERIT) &&
+		    (*flagset & ACL_ENTRY_DIRECTORY_INHERIT) == 0) {
+			continue;
+		}
+
+		/*
+		 * By the time we've gotten here, we're inheriting something somewhere.
+		 * Strip inherit only from the flagset and set ACL_ENTRY_INHERITED.
+		 * I have mixed feelings about seting INHERITED here since the ACL applies
+		 * to a dataset, and the flag may allow permissions auto-inheritance from
+		 * Windows clients.
+		 */
+		*flagset &= ~ACL_ENTRY_INHERIT_ONLY;
+		*flagset |= ACL_ENTRY_INHERITED;
+
+		if (acl_create_entry_np(&new_acl, &dir_entry, d_entry_id) == -1) {
+			DBG_ERR("acl_create_entry() failed in connectpath.\n");
+			goto failure;
+		}
+		if (acl_copy_entry(dir_entry, entry) == -1) {
+			DBG_ERR("acl_copy_entry() failed in connectpath.\n");
+			goto failure;
+		}
+		if (acl_get_flagset_np(dir_entry, &dir_flag) == -1) {
+			DBG_ERR("acl_copy_entry() failed in connectpath.\n");
+			goto failure;
+		}
+		if (*flagset & ACL_ENTRY_NO_PROPAGATE_INHERIT) {
+			*dir_flag &= ~(ACL_ENTRY_DIRECTORY_INHERIT|ACL_ENTRY_FILE_INHERIT|ACL_ENTRY_NO_PROPAGATE_INHERIT);
+		}
+		/*
+		 * If only FILE_INHERIT is set then turn on INHERIT_ONLY
+		 * on directories. This is to prevent ACE from applying to directories.
+		 */
+		else if ((*flagset & ACL_ENTRY_DIRECTORY_INHERIT) == 0) {
+			*dir_flag |= ACL_ENTRY_INHERIT_ONLY;
+		}
+	}
+	acl_free(tmp_acl);
+	return new_acl;
+failure:
+	acl_free(tmp_acl);
+	acl_free(new_acl);
+	return NULL;
+}
+
+static int create_zfs_autohomedir(vfs_handle_struct *handle,
+				  struct ixnas_config_data *config,
+				  const char *user)
+{
+	bool ret = 0;
+	int naces, rv;
+	char rp[PATH_MAX] = { 0 };
+	char *parent;
+	const char *base;
+	acl_t zacl, new_acl;
+	TALLOC_CTX *tmp_ctx = talloc_stackframe();
+	struct smblibzfshandle *libzp = NULL;
+
+	if (realpath(handle->conn->connectpath, rp)) {
+		DBG_INFO("Home directory already exists. Skipping dataset creation\n");
+		TALLOC_FREE(tmp_ctx);
+		return ret;
+	}
+
+	if (!parent_dirname(tmp_ctx, handle->conn->connectpath, &parent, &base)) {
+		TALLOC_FREE(tmp_ctx);
+		return -1;
+	}
+
+	DBG_INFO("Preparing to create dataset (%s) with parentdir (%s) with quota (%s)\n",
+		parent, base, config->homedir_quota);
+
+	rv = get_smblibzfs_handle(tmp_ctx, &libzp);
+	if (rv != 0) {
+		DBG_ERR("Failed to obtain libzfshandle on connectpath: %s\n",
+			strerror(errno));
+		return -1;
+	}
+
+	if (realpath(parent, rp) == NULL ){
+		DBG_ERR("Parent directory does not exist, attempting to create parent.\n");
+		char *grandparent;
+		const char *parent_relpath;
+		if (!parent_dirname(tmp_ctx, parent, &grandparent, &parent_relpath)) {
+			TALLOC_FREE(tmp_ctx);
+			return -1;
+		}
+		if (smb_zfs_create_child_dataset(libzp, grandparent, parent_relpath, NULL) < 0) {
+			DBG_ERR("Failed to auto-create grandparent dataset\n");
+			TALLOC_FREE(tmp_ctx);
+			return -1;
+		}
+		if ((zacl = acl_get_file(grandparent, ACL_TYPE_NFS4)) == NULL) {
+			DBG_ERR("ixnas: acl_get_file() failed for %s: %s\n",
+				parent, strerror(errno));
+			TALLOC_FREE(tmp_ctx);
+			return -1;
+		}
+		if ((new_acl = calculate_inherited_acl(zacl)) == NULL) {
+			acl_free(zacl);
+			TALLOC_FREE(tmp_ctx);
+			return -1;
+		}
+		acl_free(zacl);
+		if (acl_set_file(parent, ACL_TYPE_NFS4, new_acl) < 0) {
+			DBG_ERR("ixnas: acl_set_file() failed for %s: %s\n",
+				handle->conn->connectpath, strerror(errno));
+			acl_free(new_acl);
+			TALLOC_FREE(tmp_ctx);
+			return -1;
+		}
+		acl_free(new_acl);
+	}
+
+	if (smb_zfs_create_child_dataset(libzp, parent, base, config->homedir_quota) < 0) {
+		DBG_ERR("Failed to auto-create connectpath dataset\n");
+		TALLOC_FREE(tmp_ctx);
+		return -1;
+	}
+	if ((zacl = acl_get_file(parent, ACL_TYPE_NFS4)) == NULL) {
+		DBG_ERR("ixnas: acl_get_file() failed for %s: %s\n",
+			parent, strerror(errno));
+		TALLOC_FREE(tmp_ctx);
+		return -1;
+	}
+	if ((new_acl = calculate_inherited_acl(zacl)) == NULL) {
+		acl_free(zacl);
+		TALLOC_FREE(tmp_ctx);
+		return -1;
+	}
+	acl_free(zacl);
+
+	if (acl_set_file(handle->conn->connectpath, ACL_TYPE_NFS4, new_acl) < 0) {
+		DBG_ERR("ixnas: acl_set_file() failed for %s: %s\n",
+			handle->conn->connectpath, strerror(errno));
+		acl_free(new_acl);
+		TALLOC_FREE(tmp_ctx);
+		return -1;
+	}
+	acl_free(new_acl);
+
+	if (lp_parm_bool(SNUM(handle->conn), "ixnas", "chown_homedir", true)) {
+		struct passwd *current_user = Get_Pwnam_alloc(tmp_ctx, user);
+		if ( !current_user ) {
+			DBG_ERR("Get_Pwnam_alloc failed for (%s).\n", user);
+			TALLOC_FREE(tmp_ctx);
+			return -1;
+		}
+		if (chown(handle->conn->connectpath, current_user->pw_uid, current_user->pw_gid) < 0) {
+			DBG_ERR("Failed to chown (%s) to (%u:%u)\n",
+				handle->conn->connectpath, current_user->pw_uid, getegid() );
+			ret = -1;
+		}
+	}
+	TALLOC_FREE(tmp_ctx);
+	return ret;
+}
+
+/*
+ * Fake the presence of a base quota. Check if user quota already exists.
+ * If it exists, then we assume that the base quota has either already been set
+ * or it has been modified by the admin. In either case, do nothing.
+ */
+
+static int set_base_user_quota(vfs_handle_struct *handle,
+			       struct ixnas_config_data *config,
+			       const char *user)
+{
+	int ret;
+	uint64_t existing_quota, usedspace, base_quota;
+	existing_quota = usedspace = 0;
+	uid_t current_user = nametouid(user);
+	base_quota = config->base_user_quota / 1024;
+
+	if ( !current_user ) {
+		DBG_ERR("Failed to convert (%s) to uid.\n", user);
+		return -1;
+	}
+
+	if (smb_zfs_get_userspace_quota(config->libzp,
+			      handle->conn->connectpath,
+			      current_user,
+			      SMB_USER_QUOTA_TYPE,
+			      &existing_quota,
+			      &usedspace) < 0) {
+		DBG_ERR("Failed to get base quota uid: (%u), path (%s)\n",
+			current_user, handle->conn->connectpath );
+		return -1;
+	}
+
+	DBG_INFO("set_base_user_quote: uid (%u), quota (%lu)\n",
+		 current_user, base_quota);
+
+	if ( !existing_quota ) {
+		ret = smb_zfs_set_userspace_quota(config->libzp,
+					handle->conn->connectpath,
+					current_user,
+					SMB_USER_QUOTA_TYPE,
+					base_quota);
+		if (!ret) {
+			DBG_ERR("Failed to set base quota uid: (%u), path (%s), value (%lu)\n",
+				current_user, handle->conn->connectpath, base_quota );
+		}
+	}
+	return ret;
+}
+#endif
+
+/*
+ * Windows clients return NT_STATUS_OBJECT_NAME_COLLISION in case of
+ * rename in case of rename in case insensitive dataset. MacOS does
+ * attempts the rename. rename() in FreeBSD in this returns success, but
+ * does not actually rename the file. Add new logic to rename(). If
+ * a case_insensitive string comparison of the filenames returns 0, then
+ * perform two renames so that the returned filename matches client
+ * expectations. First rename appends a jenkins hash of the full path
+ * to the file to its name. This makes the rename deterministic, but
+ * minimizes risk of name collisions.
+ */
+static int ixnas_renameat(vfs_handle_struct *handle,
+			  files_struct *srcfsp,
+			  const struct smb_filename *smb_fname_src,
+			  files_struct *dstfsp,
+			  const struct smb_filename *smb_fname_dst)
+{
+	int result;
+	struct ixnas_config_data *config = NULL;
+	char *tmp_base_name = NULL;
+	uint32_t nhash;
+	NTSTATUS status;
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct ixnas_config_data,
+				return -1);
+
+	if (config->props->casesens != SMBZFS_INSENSITIVE) {
+		return SMB_VFS_NEXT_RENAMEAT(handle,
+					     srcfsp,
+					     smb_fname_src,
+					     dstfsp,
+					     smb_fname_dst);
+	}
+	result = strcasecmp_m(smb_fname_src->base_name,
+			      smb_fname_dst->base_name);
+	if (result != 0) {
+		return SMB_VFS_NEXT_RENAMEAT(handle,
+					     srcfsp,
+					     smb_fname_src,
+					     dstfsp,
+					     smb_fname_dst);
+	}
+	status = file_name_hash(handle->conn, smb_fname_src->base_name, &nhash);
+	if (NT_STATUS_EQUAL(status, NT_STATUS_NO_MEMORY)) {
+		DBG_ERR("failed to generate filename hash for %s\n",
+			smb_fname_src->base_name);
+		errno=ENOMEM;
+		return -1;
+	}
+	tmp_base_name = talloc_asprintf(talloc_tos(), "%s_0x%08x",
+					smb_fname_src->base_name, nhash);
+	result = rename(smb_fname_src->base_name, tmp_base_name);
+	if (result != 0) {
+		DBG_ERR("Failed to rename %s to intermediate name %s\n",
+			smb_fname_src->base_name, tmp_base_name);
+		TALLOC_FREE(tmp_base_name);
+		return result;
+	}
+	result = rename(tmp_base_name, smb_fname_dst->base_name);
+	TALLOC_FREE(tmp_base_name);
+	return result;
+}
+
+static bool is_robocopy_init(struct smb_file_time *ft)
+{
+	if (!null_timespec(ft->atime) ||
+	    null_timespec(ft->create_time)) {
+		return false;
+	}
+	if (!null_timespec(ft->mtime) &&
+	    ft->mtime.tv_sec == 315619200) {
+		return true;
+	}
+	return false;
+}
+
+static int ixnas_ntimes(vfs_handle_struct *handle,
+                                 const struct smb_filename *smb_fname,
+                                 struct smb_file_time *ft)
+{
+	int result = -1;
+	if (smb_fname->stream_name) {
+		errno = ENOENT;
+		return result;
+	}
+	/*
+	 * man utimensat(2)
+	 * If times is non-NULL, it is assumed to point to an array of two
+	 * timespec structures. The access time is set to the value of the
+	 * second element. For filesystems that support file birth (creation) times,
+	 * the birth time will be set to the value of the second element if the
+	 * second element is older than the currently set birthtime. To set both
+	 * a birth time and a modification tie, two calls are required. The first
+	 * to set the birth time and the second to set the (presumabley newer).
+	 */
+	if (ft != NULL) {
+		if (is_robocopy_init(ft)) {
+			return 0;
+		}
+		struct timespec ts[2];
+		if (null_timespec(ft->atime)) {
+			ft->atime= smb_fname->st.st_ex_atime;
+		}
+		if (null_timespec(ft->mtime)) {
+			ft->mtime = smb_fname->st.st_ex_mtime;
+		}
+		/* mtime and atime are unchanged */
+		if ((timespec_compare(&ft->atime,
+				      &smb_fname->st.st_ex_atime) == 0) &&
+		    (timespec_compare(&ft->mtime,
+				      &smb_fname->st.st_ex_mtime) == 0)) {
+			return 0;
+		}
+		/*
+		 * Perform two utimensat() calls if needed to set the specified
+		 * timestamps.
+		 */
+		if (null_timespec(ft->create_time)) {
+			ft->create_time = ft->mtime;
+		}
+		ts[0] = ft->atime;
+		ts[1] = ft->create_time;
+		result = utimensat(AT_FDCWD, smb_fname->base_name, ts, 0);
+		if (timespec_compare(&ft->mtime, &ft->create_time) != 0) {
+			ts[1] = ft->mtime;
+			result = utimensat(AT_FDCWD, smb_fname->base_name, ts, 0);
+		}
+	} else {
+		result = utimensat(AT_FDCWD, smb_fname->base_name, NULL, 0);
+	}
+ out:
+	if (result != 0) {
+		DBG_ERR("utimensat failed: %s \n", strerror(errno));
+	}
+	return result;
+}
+
+/********************************************************************
+ Optimization. Load parameters on connect. This allows us to enable
+ and disable portions of the large vfs module on demand.
+********************************************************************/
+static int ixnas_connect(struct vfs_handle_struct *handle,
+			    const char *service, const char *user)
+{
+	struct ixnas_config_data *config = NULL;
+	int ret, consens;
+	const char *homedir_quota = NULL;
+	const char *base_quota_str = NULL;
+	bool can_use_libzfs;
+	acl_t bsdacl;
+	int is_trivial = 0;
+	config = talloc_zero(handle->conn, struct ixnas_config_data);
+	if (!config) {
+		DEBUG(0, ("talloc_zero() failed\n"));
+		errno = ENOMEM;
+		return -1;
+	}
+	/*
+	 * Check if we need to automatically create a new ZFS dataset
+	 * before falling through to SMB_VFS_NEXT_CONNECT
+	 */
+#if HAVE_LIBZFS
+	config->zfs_auto_homedir = lp_parm_bool(SNUM(handle->conn),
+			"ixnas", "zfs_auto_homedir", false);
+	config->homedir_quota = lp_parm_const_string(SNUM(handle->conn),
+			"ixnas", "homedir_quota", NULL);
+
+	if (config->zfs_auto_homedir) {
+		ret = create_zfs_autohomedir(handle, config, user);
+		if (ret < 0) {
+			DBG_ERR("Failed to automatically generate connectpath.\n");
+			return -1;
+		}
+	}
+#endif
+
+	ret = SMB_VFS_NEXT_CONNECT(handle, service, user);
+	if (ret < 0) {
+		TALLOC_FREE(config);
+		return ret;
+	}
+
+#if HAVE_LIBZFS
+	config->libzp = handle->conn->sconn->libzp;
+
+	config->props = handle->conn->sconn->ds_list->root->properties;
+
+	base_quota_str = lp_parm_const_string(SNUM(handle->conn),
+			"ixnas", "base_user_quota", NULL);
+
+	if (base_quota_str != NULL) {
+		config->base_user_quota = conv_str_size(base_quota_str);
+        }
+
+	if (config->base_user_quota) {
+		set_base_user_quota(handle, config, user);
+	}
+	if (config->props->casesens == SMBZFS_INSENSITIVE) {
+		DBG_INFO("ixnas: case insensitive dataset detected, "
+			 "automatically adjusting case sensitivity settings.\n");
+		lp_do_parameter(SNUM(handle->conn),
+				"case sensitive", "yes");
+		handle->conn->case_sensitive = True;
+	}
+	config->zfs_space_enabled = lp_parm_bool(SNUM(handle->conn),
+			"ixnas", "zfs_space_enabled", true);
+
+	config->zfs_quota_enabled = lp_parm_bool(SNUM(handle->conn),
+			"ixnas", "zfs_quota_enabled", true);
+#endif
+
+	/*
+	 * Ensure other alternate methods of mapping dosmodes are disabled.
+	 */
+	config->dosattrib_xattr = lp_parm_bool(SNUM(handle->conn),
+			"ixnas", "dosattrib_xattr", false);
+
+	if (!config->dosattrib_xattr) {
+		if ((lp_map_readonly(SNUM(handle->conn))) == MAP_READONLY_YES) {
+			DBG_INFO("ixnas:dosmode to file flag mapping enabled,"
+				  "disabling 'map readonly'\n");
+			lp_do_parameter(SNUM(handle->conn), "map readonly",
+					"no");
+		}
+
+		if (lp_map_archive(SNUM(handle->conn))) {
+			DBG_INFO("ixnas:dosmode to file flag mapping enabled,"
+				  "disabling 'map archive'\n");
+			lp_do_parameter(SNUM(handle->conn), "map archive",
+					"no");
+		}
+
+		if (lp_store_dos_attributes(SNUM(handle->conn))){
+			DBG_INFO("ixnas:dosmode to file flag mapping enabled,"
+				  "disabling 'store dos attributes'\n");
+			lp_do_parameter(SNUM(handle->conn), "store dos attributes",
+					"no");
+		}
+	}
+
+	config->map_modify = lp_parm_bool(SNUM(handle->conn),
+		"ixnas", "map_modify", false);
+
+	/*
+	 * Loosen up ACL interpretation for time machine shares.
+	 * This makes our POSIX mode behave more POSIX-like over SMB,
+	 * which generally makes MacOS clients happier.
+	 */
+	if (lp_parm_bool(SNUM(handle->conn), "fruit", "time machine", false)) {
+		config->map_modify = true;
+	}
+
+	/*
+	 * Ditto for cases where the ACL on the connectpath is trivial.
+	 * If the user has only set a POSIX mode, then do our darndest
+	 * to actually make this work as expected.
+	 */
+	bsdacl = acl_get_file(handle->conn->connectpath, ACL_TYPE_NFS4);
+	if (bsdacl == NULL) {
+		DBG_ERR("Failed to retrieve connectpath ACL\n");
+		return -1;
+	}
+	ret = acl_is_trivial_np(bsdacl, &is_trivial);
+	acl_free(bsdacl);
+	if (ret != 0) {
+		DBG_ERR("Failed to determine whether connecpath ACL is trivial\n");
+		return -1;
+	}
+	if (is_trivial) {
+		config->map_modify = true;
+	}
+
+
+	config->zfs_acl_chmod_enabled = lp_parm_bool(SNUM(handle->conn),
+			"ixnas", "zfs_acl_chmod_enabled", false);
+
+	ret = smbacl4_get_vfs_params(handle->conn, &config->nfs4_params);
+	if (ret < 0) {
+		TALLOC_FREE(config);
+		return ret;
+	}
+
+	SMB_VFS_HANDLE_SET_DATA(handle, config,
+				NULL, struct ixnas_config_data,
+				return -1);
+
+	return 0;
+}
+
+static struct vfs_fn_pointers ixnas_fns = {
+	.fs_capabilities_fn = ixnas_fs_capabilities,
+	.connect_fn = ixnas_connect,
+	/* dosmode_enabled */
+	.get_dos_attributes_fn = ixnas_get_dos_attributes,
+	.fget_dos_attributes_fn = ixnas_fget_dos_attributes,
+	.set_dos_attributes_fn = ixnas_set_dos_attributes,
+	.fset_dos_attributes_fn = ixnas_fset_dos_attributes,
+	/* zfs_acl_enabled = true */
+	.chmod_fn = ixnas_chmod,
+	.fchmod_fn = ixnas_fchmod,
+	.ntimes_fn = ixnas_ntimes,
+	.renameat_fn = ixnas_renameat,
+	.fget_nt_acl_fn = ixnas_fget_nt_acl,
+	.get_nt_acl_at_fn = ixnas_get_nt_acl_at,
+	.fset_nt_acl_fn = ixnas_fset_nt_acl,
+	.sys_acl_get_file_fn = ixnas_fail__sys_acl_get_file,
+	.sys_acl_get_fd_fn = ixnas_fail__sys_acl_get_fd,
+	.sys_acl_blob_get_file_fn = ixnas_fail__sys_acl_blob_get_file,
+	.sys_acl_blob_get_fd_fn = ixnas_fail__sys_acl_blob_get_fd,
+	.sys_acl_set_file_fn = ixnas_fail__sys_acl_set_file,
+	.sys_acl_set_fd_fn = ixnas_fail__sys_acl_set_fd,
+	.sys_acl_delete_def_file_fn = ixnas_fail__sys_acl_delete_def_file,
+#if HAVE_LIBZFS
+	.get_quota_fn = ixnas_get_quota,
+	.set_quota_fn = ixnas_set_quota,
+	.disk_free_fn = ixnas_disk_free
+#endif
+};
+
+NTSTATUS vfs_ixnas_init(TALLOC_CTX *);
+NTSTATUS vfs_ixnas_init(TALLOC_CTX *ctx)
+{
+	NTSTATUS ret = smb_register_vfs(SMB_VFS_INTERFACE_VERSION, "ixnas",
+					&ixnas_fns);
+	if (!NT_STATUS_IS_OK(ret)) {
+		return ret;
+	}
+
+	vfs_ixnas_debug_level = debug_add_class("ixnas");
+	if (vfs_ixnas_debug_level == -1) {
+		vfs_ixnas_debug_level = DBGC_VFS;
+		DBG_ERR("%s: Couldn't register custom debugging class!\n",
+			"vfs_ixnas_init");
+	} else {
+		DBG_DEBUG("%s: Debug class number of '%s': %d\n",
+		"vfs_ixnas_init","ixnas",vfs_ixnas_debug_level);
+	}
+	return ret;
+}
diff --git a/source3/modules/vfs_noacl.c b/source3/modules/vfs_noacl.c
new file mode 100644
index 00000000000..992b356993c
--- /dev/null
+++ b/source3/modules/vfs_noacl.c
@@ -0,0 +1,523 @@
+/*
+ *  Unix SMB/CIFS implementation.
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "includes.h"
+#include "smbd/smbd.h"
+#include "libcli/security/security.h"
+#include "system/filesys.h"
+#include "passdb/lookup_sid.h"
+#include "librpc/gen_ndr/ndr_security.h"
+#include "../libcli/security/dom_sid.h"
+#include "../libcli/security/security.h"
+#include <sys/acl.h>
+
+static uint32_t noacl_fs_capabilities(struct vfs_handle_struct *handle,
+			enum timestamp_set_resolution *p_ts_res)
+{
+	/*
+	 * Remove flag for FILE_PERSISTENT_ACLS. MS-FSCC 2.5.1 defines as follows:
+	 * "The file system preserves and enforces access control lists (ACLs)."
+	 * Per MS-FSA Appendix A, this flag is set on ReFS and NTFS, but not
+	 * FAT, EXFAT, UDFS, CDFS.
+	 */
+	uint32_t fscaps = SMB_VFS_NEXT_FS_CAPABILITIES(handle, p_ts_res);
+	fscaps &= ~FILE_PERSISTENT_ACLS;
+	DBG_INFO("noacl: fscaps: %08x\n", fscaps);
+	return fscaps;
+}
+
+static uint32_t fileflags_to_dosmode(uint32_t fileflags)
+{
+	uint32_t dosmode = 0;
+	if (fileflags & UF_ARCHIVE){
+		dosmode |= FILE_ATTRIBUTE_ARCHIVE;
+	}
+	if (fileflags & UF_SYSTEM){
+		dosmode |= FILE_ATTRIBUTE_SYSTEM;
+	}
+	if (fileflags & UF_HIDDEN){
+		dosmode |= FILE_ATTRIBUTE_HIDDEN;
+	}
+	if (fileflags & UF_SPARSE){
+		dosmode |= FILE_ATTRIBUTE_SPARSE;
+	}
+	if (fileflags & UF_OFFLINE){
+		dosmode |= FILE_ATTRIBUTE_OFFLINE;
+	}
+
+	return dosmode;
+}
+
+static uint32_t dosmode_to_fileflags(uint32_t dosmode)
+{
+	uint32_t fileflags = 0;
+	if (dosmode & FILE_ATTRIBUTE_ARCHIVE) {
+		fileflags |= UF_ARCHIVE;
+	}
+	if (dosmode & FILE_ATTRIBUTE_HIDDEN) {
+		fileflags |= UF_HIDDEN;
+	}
+	if (dosmode & FILE_ATTRIBUTE_OFFLINE) {
+		fileflags |= UF_OFFLINE;
+	}
+	if (dosmode & FILE_ATTRIBUTE_SYSTEM) {
+		fileflags |= UF_SYSTEM;
+	}
+	if (dosmode & FILE_ATTRIBUTE_SPARSE) {
+		fileflags |= UF_SPARSE;
+	}
+
+	return fileflags;
+}
+
+static int write_dosmode_as_user(struct vfs_handle_struct *handle,
+			 const struct smb_filename *smb_fname,
+			 mode_t new_mode, uint32_t fileflags)
+{
+	int ret;
+	ret = SMB_VFS_CHMOD(handle->conn, smb_fname, new_mode);
+	if (ret != 0) {
+		DBG_ERR("Setting dosmode readonly bit failed for %s: %s\n",
+			smb_fname->base_name, strerror(errno));
+		return ret;
+	}
+	ret = SMB_VFS_CHFLAGS(handle->conn, smb_fname, fileflags);
+	if (ret != 0) {
+		DBG_ERR("Setting dosmode failed for %s: %s\n",
+			smb_fname->base_name, strerror(errno));
+		return ret;
+	}
+	return ret;
+}
+
+static NTSTATUS set_dos_attributes_common(struct vfs_handle_struct *handle,
+					 const struct smb_filename *smb_fname,
+					 uint32_t dosmode)
+{
+	/*
+	 * Use DOS READONLY to determine whether to add write bits to posix
+	 * mode. Create mask parameter can be used to limit this to owner
+	 * or group. Remaining DOS modes are mapped to file flags.
+	 * Feature request specified that changes to DOS mode must be restricted
+	 * to the file owner (not DOS semantics). This behavior will exist
+	 * if the file has a trivial ACL because only the owner of the file will
+	 * have FILE_WRITE_ATTRIBUTES.
+	 */
+	int ret;
+	bool set_dosmode_ok = false;
+	NTSTATUS status = NT_STATUS_OK;
+	uint32_t fileflags = dosmode_to_fileflags(dosmode);
+	mode_t new_mode = smb_fname->st.st_ex_mode;
+
+	DBG_INFO("noacl:set_dos_attributes: set attribute 0x%x, on file %s\n",
+		dosmode, smb_fname->base_name);
+
+
+	if (IS_DOS_READONLY(dosmode)) {
+		new_mode &= ~(S_IWUSR | S_IWGRP | S_IWOTH);
+		}
+	else {
+		new_mode |= (S_IWUSR | S_IWGRP | S_IWOTH);
+	}
+
+	if (IS_DOS_DIR(dosmode)) {
+		new_mode |= (S_IXUSR | S_IXGRP | S_IXOTH);
+		new_mode &= lp_directory_mask(SNUM(handle->conn));
+		new_mode |= lp_force_directory_mode(SNUM(handle->conn));
+	}
+	else {
+		new_mode &= lp_create_mask(SNUM(handle->conn));
+		new_mode |= lp_force_create_mode(SNUM(handle->conn));
+	}
+
+	if (!CAN_WRITE(handle->conn)) {
+		return NT_STATUS_ACCESS_DENIED;
+	}
+
+	status = smbd_check_access_rights(handle->conn, handle->conn->cwd_fsp,
+					  smb_fname, false,
+					  FILE_WRITE_ATTRIBUTES);
+
+	if (!NT_STATUS_IS_OK(status)) {
+		DBG_WARNING("User %d lacks permissions to write new dosmode\n",
+			    geteuid());
+		return status;
+	}
+
+	become_root();
+	ret = write_dosmode_as_user(handle, smb_fname, new_mode, fileflags);
+	unbecome_root();
+	if (ret == -1) {
+		DBG_WARNING("Setting dosmode failed for %s: %s\n",
+			smb_fname->base_name, strerror(errno));
+		return map_nt_error_from_unix(errno);
+	}
+
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS noacl_get_dos_attributes(struct vfs_handle_struct *handle,
+					 struct smb_filename *smb_fname,
+					 uint32_t *dosmode)
+{
+	if ((smb_fname->st.st_ex_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0) {
+		*dosmode |= FILE_ATTRIBUTE_READONLY;
+	}
+	*dosmode |= fileflags_to_dosmode(smb_fname->st.st_ex_flags);
+
+	if (S_ISDIR(smb_fname->st.st_ex_mode)) {
+	/*
+	 * Windows default behavior appears to be that the archive bit
+	 * on a directory is only explicitly set by clients. FreeBSD
+	 * sets this bit when the directory's contents are modified.
+	 */
+		*dosmode &= ~FILE_ATTRIBUTE_ARCHIVE;
+	}
+
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS noacl_fget_dos_attributes(struct vfs_handle_struct *handle,
+                                            struct files_struct *fsp,
+                                            uint32_t *dosmode)
+{
+	if ((fsp->fsp_name->st.st_ex_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0) {
+		*dosmode |= FILE_ATTRIBUTE_READONLY;
+	}
+	*dosmode |= fileflags_to_dosmode(fsp->fsp_name->st.st_ex_flags);
+
+	if (S_ISDIR(fsp->fsp_name->st.st_ex_mode)) {
+	/*
+	 * Windows default behavior appears to be that the archive bit
+	 * on a directory is only explicitly set by clients. FreeBSD
+	 * sets this bit when the directory's contents are modified.
+	 * This is a temporary hack until we can make OS behavior
+	 * configurable
+	 */
+		*dosmode &= ~FILE_ATTRIBUTE_ARCHIVE;
+	}
+
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS noacl_get_nt_acl_common(TALLOC_CTX *ctx,
+					struct vfs_handle_struct *handle,
+					const struct smb_filename *smb_fname,
+					struct security_descriptor **ppdesc)
+{
+	int ret;
+	struct dom_sid owner_sid, group_sid;
+	size_t size = 0;
+	struct security_ace aces[4];
+	uint32_t access_mask = 0;
+	mode_t mode = 0;
+	SMB_STRUCT_STAT sbuf;
+	const SMB_STRUCT_STAT *psbuf = NULL;
+	struct security_acl *new_dacl = NULL;
+	int idx = 0;
+
+	if (VALID_STAT(smb_fname->st)) {
+		psbuf = &smb_fname->st;
+	}
+
+	if (psbuf == NULL) {
+		ret = vfs_stat_smb_basename(handle->conn, smb_fname, &sbuf);
+		if (ret != 0) {
+			DBG_INFO("stat [%s]failed: %s\n",
+				smb_fname_str_dbg(smb_fname), strerror(errno));
+			return map_nt_error_from_unix(errno);
+		}
+		psbuf = &sbuf;
+	}
+	mode = psbuf->st_ex_mode;
+
+	DBG_DEBUG("file %s mode = 0%o\n",smb_fname->base_name, (int)mode);
+
+	uid_to_sid(&owner_sid, psbuf->st_ex_uid);
+	gid_to_sid(&group_sid, psbuf->st_ex_gid);
+
+	/*
+	 * SEC_FILE_WRITE_EA | SEC_FILE_WRITE_ATTRIBUTE always granted for file
+	 * owner. This better reflects the truth regarding what the owner can
+	 * actually do.
+	 */
+	if (mode & S_IRUSR) {
+		if (mode & S_IWUSR) {
+			access_mask |= SEC_RIGHTS_FILE_ALL;
+		} else {
+			access_mask |= SEC_RIGHTS_FILE_READ | SEC_FILE_EXECUTE \
+				    | SEC_FILE_WRITE_EA | SEC_FILE_WRITE_ATTRIBUTE;
+		}
+	}
+	if (mode & S_IWUSR) {
+		access_mask |= SEC_RIGHTS_FILE_WRITE | SEC_STD_DELETE;
+	}
+
+	init_sec_ace(&aces[idx],
+			&owner_sid,
+			SEC_ACE_TYPE_ACCESS_ALLOWED,
+			access_mask,
+			0);
+	idx++;
+
+	access_mask = 0;
+	if (mode & S_IRGRP) {
+		access_mask |= SEC_RIGHTS_FILE_READ | SEC_FILE_EXECUTE;
+	}
+	if (mode & S_IWGRP) {
+		access_mask |= SEC_RIGHTS_FILE_WRITE | SEC_STD_DELETE;
+	}
+	if (lp_dos_filemode(SNUM(handle->conn))) {
+		access_mask |= SEC_FILE_WRITE_ATTRIBUTE;
+	}
+	if (access_mask) {
+		init_sec_ace(&aces[idx],
+			&group_sid,
+			SEC_ACE_TYPE_ACCESS_ALLOWED,
+			access_mask,
+			0);
+		idx++;
+	}
+
+	access_mask = 0;
+	if (mode & S_IROTH) {
+		access_mask |= SEC_RIGHTS_FILE_READ | SEC_FILE_EXECUTE;
+	}
+	if (mode & S_IWOTH) {
+		access_mask |= SEC_RIGHTS_FILE_WRITE | SEC_STD_DELETE;
+	}
+	if (lp_dos_filemode(SNUM(handle->conn))) {
+		access_mask |= SEC_FILE_WRITE_ATTRIBUTE;
+	}
+	if (access_mask) {
+		init_sec_ace(&aces[idx],
+			&global_sid_World,
+			SEC_ACE_TYPE_ACCESS_ALLOWED,
+			access_mask,
+			0);
+		idx++;
+	}
+
+	new_dacl = make_sec_acl(ctx,
+			NT4_ACL_REVISION,
+			idx,
+			aces);
+
+	if (!new_dacl) {
+		return NT_STATUS_NO_MEMORY;
+	}
+
+	*ppdesc = make_sec_desc(ctx,
+			SECURITY_DESCRIPTOR_REVISION_1,
+			SEC_DESC_SELF_RELATIVE|SEC_DESC_DACL_PRESENT,
+			&owner_sid,
+			&group_sid,
+			NULL,
+			new_dacl,
+			&size);
+	if (!*ppdesc) {
+		return NT_STATUS_NO_MEMORY;
+	}
+	return NT_STATUS_OK;
+}
+
+static NTSTATUS noacl_get_nt_acl_at(struct vfs_handle_struct *handle,
+				 struct files_struct *dirfsp,
+				 const struct smb_filename *smb_fname,
+				 uint32_t security_info,
+				 TALLOC_CTX *mem_ctx,
+				 struct security_descriptor **ppdesc)
+{
+	return noacl_get_nt_acl_common(mem_ctx,
+				       handle,
+				       smb_fname,
+				       ppdesc);
+}
+
+static NTSTATUS noacl_fget_nt_acl(struct vfs_handle_struct *handle,
+				  struct files_struct *fsp,
+				  uint32_t security_info,
+				  TALLOC_CTX *mem_ctx,
+				  struct security_descriptor **ppdesc)
+{
+	return noacl_get_nt_acl_common(mem_ctx,
+				       handle,
+				       fsp->fsp_name,
+				       ppdesc);
+}
+
+static NTSTATUS noacl_set_dos_attributes(struct vfs_handle_struct *handle,
+                                           const struct smb_filename *smb_fname,
+                                           uint32_t dosmode)
+{
+	NTSTATUS ret;
+
+	ret = set_dos_attributes_common(handle, smb_fname, dosmode);
+
+	return ret;
+}
+
+static NTSTATUS noacl_fset_dos_attributes(struct vfs_handle_struct *handle,
+                                            struct files_struct *fsp,
+                                            uint32_t dosmode)
+{
+	NTSTATUS ret;
+
+	ret = set_dos_attributes_common(handle, fsp->fsp_name, dosmode);
+
+	return ret;
+}
+
+static NTSTATUS noacl_fset_nt_acl(vfs_handle_struct *handle,
+			 files_struct *fsp,
+			 uint32_t security_info_sent,
+			 const struct security_descriptor *psd)
+{
+	return NT_STATUS_ACCESS_DENIED;
+}
+
+static SMB_ACL_T noacl_fail__sys_acl_get_file(vfs_handle_struct *handle,
+					const struct smb_filename *smb_fname,
+					SMB_ACL_TYPE_T type,
+					TALLOC_CTX *mem_ctx)
+{
+	return (SMB_ACL_T)NULL;
+}
+
+static SMB_ACL_T noacl_fail__sys_acl_get_fd(vfs_handle_struct *handle,
+					     files_struct *fsp,
+					     TALLOC_CTX *mem_ctx)
+{
+	return (SMB_ACL_T)NULL;
+}
+
+static int noacl_fail__sys_acl_set_file(vfs_handle_struct *handle,
+					 const struct smb_filename *smb_fname,
+					 SMB_ACL_TYPE_T type,
+					 SMB_ACL_T theacl)
+{
+	return -1;
+}
+
+static int noacl_fail__sys_acl_set_fd(vfs_handle_struct *handle,
+				       files_struct *fsp,
+				       SMB_ACL_T theacl)
+{
+	return -1;
+}
+
+static int noacl_fail__sys_acl_delete_def_file(vfs_handle_struct *handle,
+			const struct smb_filename *smb_fname)
+{
+	return -1;
+}
+
+static int noacl_fail__sys_acl_blob_get_file(vfs_handle_struct *handle,
+			const struct smb_filename *smb_fname,
+			TALLOC_CTX *mem_ctx,
+			char **blob_description,
+			DATA_BLOB *blob)
+{
+	return -1;
+}
+
+static int noacl_fail__sys_acl_blob_get_fd(vfs_handle_struct *handle, files_struct *fsp, TALLOC_CTX *mem_ctx, char **blob_description, DATA_BLOB *blob)
+{
+	return -1;
+}
+
+
+static int noacl_connect(struct vfs_handle_struct *handle,
+			    const char *service, const char *user)
+{
+
+	acl_t connectpath_acl;
+	int trivial, ret;
+	connectpath_acl = acl_get_file(handle->conn->connectpath, ACL_TYPE_NFS4);
+	if (connectpath_acl == NULL) {
+		DBG_ERR("noacl: acl_get_file() failed for %s: %s\n",
+			handle->conn->connectpath, strerror(errno));
+		return -1;
+	}
+	if (acl_is_trivial_np(connectpath_acl, &trivial) != 0) {
+		DBG_ERR("noacl: acl_is_trivial() failed for %s: %s\n",
+			handle->conn->connectpath, strerror(errno));
+		acl_free(connectpath_acl);
+		return -1;
+	}
+	acl_free(connectpath_acl);
+	if (trivial == 0) {
+		DBG_ERR("noacl: non-trivial ACL detected on conncectpath %s. "
+			"Denying access to share\n", handle->conn->connectpath);
+		return -1;
+	}
+	if ((lp_map_readonly(SNUM(handle->conn))) == MAP_READONLY_YES) {
+		DBG_INFO("noacl:dosmode to file flag mapping enabled,"
+			  "disabling 'map readonly'\n");
+		lp_do_parameter(SNUM(handle->conn), "map readonly",
+				"no");
+	}
+
+	if (lp_map_archive(SNUM(handle->conn))) {
+		DBG_INFO("noacl:dosmode to file flag mapping enabled,"
+			  "disabling 'map archive'\n");
+		lp_do_parameter(SNUM(handle->conn), "map archive",
+				"no");
+	}
+	lp_do_parameter(SNUM(handle->conn), "nt acl support", "no");
+	lp_do_parameter(SNUM(handle->conn), "store dos attributes", "no");
+	if (lp_parm_bool(SNUM(handle->conn), "noacl", "chroot", false)) {
+		ret = chdir(handle->conn->connectpath);
+		if (ret != 0) {
+			DBG_ERR("chdir() to connectpath failed\n");
+			return -1;
+		}
+		ret = chroot(handle->conn->connectpath);
+		if (ret != 0) {
+			DBG_ERR("chroot to connectpath failed\n");
+			return -1;
+		}
+		handle->conn->connectpath = talloc_strdup(handle->conn, "/");
+	}
+
+	return SMB_VFS_NEXT_CONNECT(handle, service, user);
+}
+
+static struct vfs_fn_pointers noacl_fns = {
+	.fs_capabilities_fn = noacl_fs_capabilities,
+	.connect_fn = noacl_connect,
+	.get_dos_attributes_fn = noacl_get_dos_attributes,
+	.fget_dos_attributes_fn = noacl_fget_dos_attributes,
+	.set_dos_attributes_fn = noacl_set_dos_attributes,
+	.fset_dos_attributes_fn = noacl_fset_dos_attributes,
+	.fset_nt_acl_fn = noacl_fset_nt_acl,
+	.get_nt_acl_at_fn = noacl_get_nt_acl_at,
+	.fget_nt_acl_fn = noacl_fget_nt_acl,
+	.sys_acl_get_file_fn = noacl_fail__sys_acl_get_file,
+	.sys_acl_get_fd_fn = noacl_fail__sys_acl_get_fd,
+	.sys_acl_blob_get_file_fn = noacl_fail__sys_acl_blob_get_file,
+	.sys_acl_blob_get_fd_fn = noacl_fail__sys_acl_blob_get_fd,
+	.sys_acl_set_file_fn = noacl_fail__sys_acl_set_file,
+	.sys_acl_set_fd_fn = noacl_fail__sys_acl_set_fd,
+	.sys_acl_delete_def_file_fn = noacl_fail__sys_acl_delete_def_file,
+};
+
+NTSTATUS vfs_noacl_init(TALLOC_CTX *);
+NTSTATUS vfs_noacl_init(TALLOC_CTX *ctx)
+{
+	return smb_register_vfs(SMB_VFS_INTERFACE_VERSION, "noacl",
+				&noacl_fns);
+}
diff --git a/source3/modules/vfs_winmsa.c b/source3/modules/vfs_winmsa.c
new file mode 100644
index 00000000000..970bde437c0
--- /dev/null
+++ b/source3/modules/vfs_winmsa.c
@@ -0,0 +1,334 @@
+/*
+ *  *	Windows MoveSecurityAttributes
+ *   */
+
+#include "includes.h"
+#include "system/filesys.h"
+#include "smbd/smbd.h"
+#include "nfs4_acls.h"
+
+#if HAVE_FREEBSD_SUNACL_H
+#include "sunacl.h"
+#endif
+
+#ifndef NAME_MAX
+#define NAME_MAX 255
+#endif
+
+#undef DBGC_CLASS
+#define DBGC_CLASS DBGC_VFS
+
+#define WINMSA_MODULE_NAME "winmsa"
+
+typedef struct winmsa_info {
+	int d_naces;
+	int f_naces;
+	ace_t *d_aces;
+	ace_t *f_aces;
+	uid_t uid;
+	gid_t gid;
+	char *path;
+} winmsa_info_t;
+
+
+static char *parent_dir(TALLOC_CTX *ctx, const char *name)
+{
+	const char *p = strrchr(name, '/');
+	if (p == NULL)
+		return NULL;
+
+	return  talloc_strndup(ctx, name, (p + 1) - name);
+}
+
+static void winmsa_dump_acl(const char *path, ace_t *aces, int naces)
+{
+	int i;
+
+	DEBUG(5, ("PATH=%s\n", path));
+	for (i = 0;i < naces;i++) {
+		ace_t *ace = &(aces[i]);
+		DEBUG(5, ("ACE: [%02d/%02d] who=%08x [%-10d] mask=%08x flags=%08x type=%08x\n",
+			i + 1, naces, ace->a_who, ace->a_who, ace->a_access_mask, ace->a_flags, ace->a_type));
+	}
+}
+
+static int winmsa_get_naces(const char *path)
+{
+	int naces;
+
+	if ((naces = acl(path, ACE_GETACLCNT, 0, NULL)) < 0) {
+		if(errno == ENOSYS) {
+			DEBUG(5, ("acl(ACE_GETACLCNT, %s): Operation is not "
+				"supported on the filesystem where the file reside\n", path));
+		} else {
+			DEBUG(5, ("acl(ACE_GETACLCNT, %s): %s ", path, strerror(errno)));
+		}
+		return -1;
+	}
+
+	return naces;
+}
+
+static int winmsa_get_acl(TALLOC_CTX *ctx, winmsa_info_t *info)
+{
+	int i;
+
+	if (info == NULL || info->path == NULL)
+		return -1;
+
+	if ((info->d_naces = winmsa_get_naces(info->path)) < 0)
+		return -1;
+
+	if ((info->d_aces = talloc_size(ctx, sizeof(ace_t) * info->d_naces)) == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+
+	if ((acl(info->path, ACE_GETACL, info->d_naces, info->d_aces)) < 0) {
+		DEBUG(3, ("winmsa_get_acl(%s): %s ", info->path, strerror(errno)));
+		return -1;
+	}
+
+	for (i = 0;i < info->d_naces;i++) {
+		info->d_aces[i].a_flags |= ACE_INHERITED_ACE;
+	}
+	
+	return 0;
+}
+
+static int winmsa_file_acl(TALLOC_CTX *ctx, winmsa_info_t *info)	
+{
+	int i;
+
+	if (info == NULL || info->path == NULL)
+		return -1;
+
+	if ((info->f_naces = winmsa_get_naces(info->path)) < 0)
+		return -1;
+
+	if ((info->f_aces = talloc_size(ctx, sizeof(ace_t) * info->f_naces)) == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+
+	if ((acl(info->path, ACE_GETACL, info->f_naces, info->f_aces)) < 0) {
+		DEBUG(3, ("winmsa_file_acl(%s): %s ", info->path, strerror(errno)));
+		return -1;
+	}
+
+	for (i = 0;i < info->f_naces;i++) {
+		info->f_aces[i].a_flags &= ~(
+			ACE_FILE_INHERIT_ACE|
+			ACE_DIRECTORY_INHERIT_ACE|
+			ACE_NO_PROPAGATE_INHERIT_ACE|
+			ACE_INHERIT_ONLY_ACE
+		);
+		
+		info->f_aces[i].a_flags |= ACE_INHERITED_ACE;
+	}
+
+	return 0;
+}
+
+static int winmsa_get_ownership(winmsa_info_t *info)
+{
+	SMB_STRUCT_STAT sbuf;
+
+	if (sys_lstat(info->path, &sbuf, false) < 0) {
+		DEBUG(3, ("winmsa_get_ownership: stat failed for %s\n", info->path));
+		return -1;
+	}
+
+	info->uid = sbuf.st_ex_uid;
+	info->gid = sbuf.st_ex_gid;
+
+	return 0;
+}
+
+/* this  routine must be called under a become_root context to operate with sufficent access */
+static int winmsa_set_acls(TALLOC_CTX *ctx, struct vfs_handle_struct *handle,
+						winmsa_info_t *info, const char *path)
+{
+	int ret;
+	DIR *dh;
+	struct dirent de;
+	struct dirent *result;
+	SMB_STRUCT_STAT sbuf;
+
+	if (sys_lstat(path, &sbuf, false) < 0) {
+		DEBUG(3, ("winmsa_set_acls: stat failed for %s\n", path));
+		return -1;
+	}
+
+	if (S_ISLNK(sbuf.st_ex_mode))
+		return 0;
+
+	if (!S_ISDIR(sbuf.st_ex_mode)) {
+		/* these calls require escalated privileges */
+		if (lp_parm_bool(handle->conn->params->service, "winmsa", "chown", True)){
+			if (chown(path, info->uid, info->gid) < 0)
+				DEBUG(3, ("winmsa_set_acls: chown failed for %s\n", path));
+		}
+
+		if (acl(path, ACE_SETACL, info->f_naces, info->f_aces) < 0)
+			DEBUG(3, ("winmsa_set_acls: acl failed for %s\n", path));
+		return 0;
+	}
+
+	if ((dh = opendir(path)) == NULL) {
+		DEBUG(3, ("winmsa_set_acls: opendir failed for %s\n", path));
+		return -1;
+	}
+
+	for (ret = readdir_r(dh, &de, &result); result != NULL && ret == 0; ret = readdir_r(dh, &de, &result)) {
+		char *rp, *buf;
+
+		if (strcmp(de.d_name, ".") == 0 ||
+			strcmp(de.d_name, "..") == 0) {
+			continue;
+		}
+
+		if ((rp = talloc_size(ctx, PATH_MAX)) == NULL) {
+			errno = ENOMEM;
+			closedir(dh);
+			return -1;
+		}
+
+		if (realpath(path, rp) == NULL) {
+			talloc_free(rp);
+			DEBUG(3, ("winmsa_set_acls: realpath failed for %s\n", path));
+			continue;
+		}
+
+		if ((buf = talloc_size(ctx, PATH_MAX)) == NULL) {
+			talloc_free(rp);
+			errno = ENOMEM;
+			closedir(dh);
+			return -1;
+		}
+
+		snprintf(buf, PATH_MAX, "%s/%s", rp, de.d_name);
+		talloc_free(rp);
+
+		winmsa_set_acls(ctx, handle, info, buf);
+		talloc_free(buf);
+	}
+
+	closedir(dh);
+
+	/* these calls may require escalated privileges */
+	if (lp_parm_bool(handle->conn->params->service, "winmsa", "chown", True)){
+ 		if (chown(path, info->uid, info->gid) < 0)
+			DEBUG(3, ("winmsa_set_acls: chown failed for %s\n", path));
+	}
+ 
+	if (acl(path, ACE_SETACL, info->d_naces, info->d_aces) < 0)
+		DEBUG(3, ("winmsa_set_acls: acl failed for %s\n", path));
+
+	return 0;
+}
+
+static int winmsa_renameat(vfs_handle_struct *handle,
+			   files_struct *srcfsp,
+			   const struct smb_filename *smb_fname_src,
+			   files_struct *dstfsp,
+			   const struct smb_filename *smb_fname_dst)
+{
+
+	int result = -1;
+	winmsa_info_t *info;
+	char *parent, *p1, *p2, *dst;
+	TALLOC_CTX *ctx;
+
+
+	if (SMB_VFS_NEXT_RENAMEAT(handle, srcfsp, smb_fname_src, dstfsp, smb_fname_dst) < 0) {
+		DEBUG(3, ("winmsa_rename: rename failed: %s\n", strerror(errno)));
+		result = -1;
+		goto out;
+	}
+
+	if ((ctx = talloc_new(NULL)) == NULL) {
+		DEBUG(3, ("winmsa_rename: talloc failed\n"));
+		result = -1;
+		goto out;
+	}
+
+	p1 = parent_dir(ctx, smb_fname_src->base_name);
+	p2 = parent_dir(ctx, smb_fname_dst->base_name);
+
+	if (p1 != NULL && p2 != NULL && strcmp(p1, p2) == 0) {
+		DEBUG(5, ("winmsa_rename: source and destination parent directory is the same\n"));
+		result = 0;
+		goto out;
+	}
+
+	if ((parent = parent_dir(ctx, smb_fname_dst->base_name)) == NULL) {
+		result = 0;
+		goto out;
+	}
+
+	if ((info = talloc_size(ctx, sizeof(winmsa_info_t))) == NULL) {
+		DEBUG(3, ("winmsa_rename: talloc_size failed\n"));
+		result = -1;
+		goto out;
+	}
+
+	info->path = talloc_size(ctx, PATH_MAX);
+	if (realpath(parent, info->path) == NULL) {
+		DEBUG(3, ("winmsa_rename: realpath failed for %s\n", parent));
+		result = -1;
+		goto out;
+	}
+
+	dst = talloc_size(ctx, PATH_MAX);
+	if (realpath(smb_fname_dst->base_name, dst) == NULL) {
+		DEBUG(3, ("winmsa_rename: realpath failed for %s\n", smb_fname_dst->base_name));
+		result = -1;
+		goto out;
+	}
+
+	if (winmsa_get_acl(ctx, info) < 0) {
+		DEBUG(3, ("winmsa_rename: winmsa_get_acl failed\n"));
+		result = -1;
+		goto out;
+	}
+
+	if (winmsa_file_acl(ctx, info) < 0) {
+		DEBUG(3, ("winmsa_rename: winmsa_file_acl failed\n"));
+		result = -1;
+		goto out;
+	}
+
+	if (winmsa_get_ownership(info) < 0) {
+		DEBUG(3, ("winmsa_rename: winmsa_get_ownership failed\n"));
+		result = -1;
+		goto out;
+	}
+
+	/* WinMSA theory of operation requires setting the new file to  clone the ACE and Ownership
+ * 	of the parent of destination directory. Field deployment showed ( see jrq-485 )
+ * 		that the effective user did not always have the UNIX rights to accomplish this. 
+ * 			We become root here for the minimal necessary time due to multiple returns in
+ * 				winmsa_set_acls and goto's in this routine. */
+	become_root(); 
+	if ((result = winmsa_set_acls(ctx, handle, info, dst)) < 0) {
+		DEBUG(3, ("winmsa_rename: winmsa_set_acls failed\n"));
+		result = -1;
+	}
+	unbecome_root(); 
+
+out:
+	TALLOC_FREE(ctx);
+	return result;
+}
+
+static struct vfs_fn_pointers winmsa_fns = {
+	.renameat_fn = winmsa_renameat,
+};
+
+NTSTATUS vfs_winmsa_init(TALLOC_CTX *);
+NTSTATUS vfs_winmsa_init(TALLOC_CTX *ctx)
+{
+	return smb_register_vfs(SMB_VFS_INTERFACE_VERSION, "winmsa",
+				&winmsa_fns);
+}
diff --git a/source3/modules/vfs_zfs_space.c b/source3/modules/vfs_zfs_space.c
new file mode 100644
index 00000000000..c1a810fc08c
--- /dev/null
+++ b/source3/modules/vfs_zfs_space.c
@@ -0,0 +1,103 @@
+/*-
+ * Copyright 2015 iXsystems, Inc.
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "includes.h"
+#include "system/filesys.h"
+#include "lib/util/tevent_ntstatus.h"
+
+#include "modules/smb_libzfs.h"
+
+struct zfs_space_config_data {
+	struct smblibzfshandle *libzp;
+};
+
+static uint64_t vfs_zfs_space_disk_free(vfs_handle_struct *handle, const struct smb_filename *smb_fname,
+    uint64_t *bsize, uint64_t *dfree, uint64_t *dsize)
+{
+	uint64_t res;
+	char rp[PATH_MAX] = { 0 };
+	struct zfs_space_config_data *config = NULL;
+	SMB_VFS_HANDLE_GET_DATA(handle, config,
+				struct zfs_space_config_data,
+				return -1);
+
+	if (realpath(smb_fname->base_name, rp) == NULL)
+		return (-1);
+
+	DEBUG(9, ("realpath = %s\n", rp));
+
+	res = smb_zfs_disk_free(config->libzp, rp, bsize, dfree, dsize, geteuid());
+	if (res == (uint64_t)-1)
+		res = SMB_VFS_NEXT_DISK_FREE(handle, smb_fname, bsize, dfree, dsize);
+	if (res == (uint64_t)-1)
+		return (res);
+
+	DEBUG(9, ("*bsize = %" PRIu64 "\n", *bsize));
+	DEBUG(9, ("*dfree = %" PRIu64 "\n", *dfree));
+	DEBUG(9, ("*dsize = %" PRIu64 "\n", *dsize));
+
+	return (res);
+}
+
+static int vfs_zfs_space_connect(struct vfs_handle_struct *handle,
+                            const char *service, const char *user)
+{
+	int ret;
+	struct zfs_space_config_data *config = NULL;
+	struct smblibzfshandle *libzp = NULL;
+
+	config = talloc_zero(handle->conn, struct zfs_space_config_data);
+	if (!config) {
+		DBG_ERR("talloc_zero() failed\n");
+		errno = ENOMEM;
+		return -1;
+	}
+
+	ret = get_smblibzfs_handle(handle->conn, &libzp);
+	if (ret != 0) {
+		DBG_ERR("Failed to get smblibzfs handle\n");
+		errno = ENOMEM;
+		return -1;
+	}
+	config->libzp = libzp;
+	SMB_VFS_HANDLE_SET_DATA(handle, config,
+				NULL, struct zfs_space_config_data,
+				return -1);
+	return SMB_VFS_NEXT_CONNECT(handle, service, user);
+}
+
+static struct vfs_fn_pointers vfs_zfs_space_fns = {
+	.disk_free_fn = vfs_zfs_space_disk_free,
+	.connect_fn = vfs_zfs_space_connect
+};
+
+NTSTATUS vfs_zfs_space_init(TALLOC_CTX *);
+NTSTATUS vfs_zfs_space_init(TALLOC_CTX *ctx)
+{
+	return smb_register_vfs(SMB_VFS_INTERFACE_VERSION,
+		"zfs_space", &vfs_zfs_space_fns);
+}
